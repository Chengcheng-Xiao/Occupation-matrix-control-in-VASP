diff -ruN ./src/LDApU.F ../../vasp.5.4.4/src/LDApU.F
--- ./src/LDApU.F	2017-04-20 17:03:57.000000000 +0800
+++ ../../vasp.5.4.4/src/LDApU.F	2019-04-16 21:00:18.528036082 +0800
@@ -1,17 +1,17 @@
 #include "symbol.inc"
 !***********************************************************************
 !
-! LDA+U Module written by Olivier Bengone 
+! LDA+U Module written by Olivier Bengone
 ! please direct any queries related to this module directly to Olivier
 ! Bengone
 !  present email address:   olivier@fysik.uu.se
-! in case you can not reach Olivier you might contact 
+! in case you can not reach Olivier you might contact
 !  Georg.Kresse@univie.ac.at
 !
 !***********************************************************************
 
       MODULE LDAPLUSU_MODULE
-      
+
       USE prec
       USE vaspxml
 
@@ -22,47 +22,53 @@
       LOGICAL, PRIVATE, SAVE :: LORBMOM                       ! calculate orbital moments?
 
       INTEGER, PRIVATE, SAVE :: LMAX_,LMMAX_,LNMAX_
-      INTEGER, PRIVATE, SAVE :: NCDIJ      
+      INTEGER, PRIVATE, SAVE :: NCDIJ
       INTEGER, PRIVATE, SAVE :: PRINTOCC=0                    ! IF /= 0 print test information
-      INTEGER, PRIVATE, SAVE :: TYPE_POT                      ! type of LDA+U potential (1 or 2)  
+      INTEGER, PRIVATE, SAVE :: TYPE_POT                      ! type of LDA+U potential (1 or 2)
       INTEGER, PRIVATE, ALLOCATABLE,SAVE :: LANG_LDAPLUSU(:)  ! l-quantum number for LDA+U correction per type
 
       REAL(q), PRIVATE, SAVE :: DOUBLEC_LDAPLUSU=0._q         ! total LDA+U double counting energy
       REAL(q), PRIVATE, ALLOCATABLE, SAVE :: U(:)             ! U parameter per type
       REAL(q), PRIVATE, ALLOCATABLE, SAVE :: J(:)             ! J parameter per type
-                                               
+
       OVERLAP , PRIVATE, ALLOCATABLE :: OCC_MAT(:,:,:)
       OVERLAP , PRIVATE, ALLOCATABLE :: OCC_MAT_ALL(:,:,:,:)
       REAL(q), PRIVATE, ALLOCATABLE, SAVE :: OVERLAP_AE_(:,:,:)
       REAL(q), PRIVATE, ALLOCATABLE, SAVE :: ORBMOM(:,:,:)
 
       COMPLEX(q), PRIVATE, SAVE :: V(7,7,7,7)
-        
+! GWW - input occupation matrix
+      OVERLAP, PRIVATE, ALLOCATABLE, SAVE :: OCC_MAT_INPUT(:,:,:,:)
+      INTEGER, PRIVATE, ALLOCATABLE, SAVE :: ATOM_OCC(:)
+      INTEGER, PRIVATE, ALLOCATABLE, SAVE :: ATOM_L(:)
+      INTEGER, PRIVATE, SAVE :: OCC_NATOMS, OCC_PNATOMS
+! END GWW
+
       CONTAINS
 
 !**********************************************************************
 !      LDAU_READER
-!                                           
-! this subroutine reads the required  parameters from the INCAR file        
-!               
-! LDAU     = .TRUE. or .FALSE.                                   
+!
+! this subroutine reads the required  parameters from the INCAR file
+!
+! LDAU     = .TRUE. or .FALSE.
 ! LDAUTYPE = 1 or 2
 !            1  use exact four center coulomb integrals
-!            2  use only U_eff=U-J                                       
+!            2  use only U_eff=U-J
 ! LDAUL   l-quantum number on which U acts (one value for each species)
 ! LDAUU   U coefficient (coulomb interaction) for each species
 ! LDAUJ   J coefficient (exchange) for each species
 !
 !**********************************************************************
 
-      SUBROUTINE LDAU_READER(NTYP,IU5,IU0) 
+      SUBROUTINE LDAU_READER(NTYP,IU5,IU0)
       USE base
       USE vaspxml
-   
-      IMPLICIT NONE 
+
+      IMPLICIT NONE
 
       INTEGER IU5,IU0
-      INTEGER ITYP,NTYP  
+      INTEGER ITYP,NTYP
       INTEGER IDUM, N, IERR
       REAL(q) RDUM
       COMPLEX(q) CDUM
@@ -73,7 +79,7 @@
       OPEN(UNIT=IU5,FILE=INCAR,STATUS='OLD')
 
 !=======================================================================
-!    read LDA+U parameters from INCAR  
+!    read LDA+U parameters from INCAR
 !=======================================================================
       TLDA_U=.FALSE.
       CALL RDATAB(LOPEN,INCAR,IU5,'LDAU','=','#',';','L', &
@@ -87,7 +93,7 @@
          ENDIF
       ENDIF
       CALL XML_INCAR('LDAU','L',IDUM,RDUM,CDUM,TLDA_U,CHARAC,N)
-       
+
       TYPE_POT=2
       CALL RDATAB(LOPEN,INCAR,IU5,'LDAUTYPE','=','#',';','I', &
      &   TYPE_POT,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
@@ -98,7 +104,7 @@
          ENDIF
          TLDA_U=.FALSE.
       ENDIF
-      
+
       CALL XML_INCAR_V('LDAUTYPE','I',TYPE_POT,RDUM,CDUM,LDUM,CHARAC,N)
 
       ALLOCATE(LANG_LDAPLUSU(NTYP),U(NTYP),J(NTYP))
@@ -114,12 +120,12 @@
          TLDA_U=.FALSE.
       ENDIF
       CALL XML_INCAR_V('LDAUL','I',LANG_LDAPLUSU,RDUM,CDUM,LDUM,CHARAC,N)
-   
+
 !       DO N=1,NTYP
 !       IF (LANG_LDAPLUSU(N) /= 2 .AND. LANG_LDAPLUSU(N) /= -1 ) THEN
 !          IF (IU0>=0) &
 !             WRITE(IU0,'(A,I3,A)')' WARNING: LDA+U for L=',LANG_LDAPLUSU(N),' LDAUTYPE must be set to 2'
-!             TYPE_POT = 2 
+!             TYPE_POT = 2
 !          ENDIF
 !       ENDDO
 
@@ -175,31 +181,56 @@
       CLOSE(IU5)
 
       RETURN
-      END SUBROUTINE LDAU_READER   
+      END SUBROUTINE LDAU_READER
 
 
-      SUBROUTINE INITIALIZE_LDAU(NIONS,NTYP,P,LNONCOLLINEAR,IU,IDIOT)
-      
+! GWW - change for occupation matrix
+      SUBROUTINE INITIALIZE_LDAU(NIONS,NTYP,P,LNONCOLLINEAR,IU5,IU6,IU,IDIOT)
+! GWW
+
       USE pseudo
-      
+
       IMPLICIT NONE
-      
+
       INTEGER NIONS,NTYP
-      
+
       TYPE(potcar) P(NTYP)
 
       INTEGER ITYP,ISPIN
       INTEGER LNMAX,LMMAX
       LOGICAL LNONCOLLINEAR
-      
+
       INTEGER IU,IDIOT,ITUT,IDUM
       REAL(q) RTUT,RDUM
       COMPLEX(q) CDUM
       LOGICAL LDUM
+!GWW occupation matrix - for the I/O
+      INTEGER, PARAMETER :: NDIM=500
+      INTEGER :: IU5,IU6
+      INTEGER :: N, IERR, ITMP
+      LOGICAL :: LOPEN
+      CHARACTER (1) :: CHARAC
+      REAL(q) :: FTMP(NDIM)
+
+!GWW for occupation matrix
+      INTEGER :: NUM_ORB
+      INTEGER :: START
+      INTEGER :: occ_spin
+      INTEGER :: i, ii, j, jj, i1, i2, is
+      CHARACTER (10)  ::  Keyword
+      CHARACTER (3)  ::  keynum
+!GWW
 
       NCDIJ=2
       IF (LNONCOLLINEAR) NCDIJ=4
 
+!GWW - occupation matrix - for reading INCAR
+      LOPEN=.FALSE.
+      OPEN(UNIT=IU5,FILE='INCAR',STATUS='OLD')
+!GWW
+
+
+
 !=======================================================================
 !  Sanity check: L(S)DA+U only implemented for PAW potentials
 !=======================================================================
@@ -210,7 +241,7 @@
       ENDDO
 
 !=======================================================================
-!  allocate objects for lda+u calculations         
+!  allocate objects for lda+u calculations
 !=======================================================================
       LMAX_=0;LMMAX_=0;LNMAX_=0
 
@@ -221,7 +252,7 @@
       LMMAX_=(LMAX_+1)**2
 
       ALLOCATE(OVERLAP_AE_(LNMAX_,LNMAX_,NTYP),OCC_MAT(LMMAX_,LMMAX_,NCDIJ), &
-     &          OCC_MAT_ALL(LMMAX_,LMMAX_,NCDIJ,NIONS)) 
+     &          OCC_MAT_ALL(LMMAX_,LMMAX_,NCDIJ,NIONS))
 
       OCC_MAT_ALL=0._q
       OVERLAP_AE_=0._q
@@ -231,9 +262,224 @@
          ALLOCATE(ORBMOM(LMAX_,3,NIONS))
          ORBMOM=0._q
       ENDIF
-      
-      RETURN 
-      END SUBROUTINE INITIALIZE_LDAU 
+
+!----------------------------------------------------------------------
+! GWW - input of occupation matrix
+
+      ALLOCATE(OCC_MAT_INPUT(16,16,NCDIJ,NIONS))
+#ifdef realmode
+      OCC_MAT_INPUT=0._q
+#else
+      OCC_MAT_INPUT=(0._q,0_q )
+#endif
+      ALLOCATE(ATOM_OCC(NIONS),ATOM_L(NIONS))
+
+! Occupation matric input allowing specifcation of matrix elements
+! up to 999 line in INCAR !  OCCDIRX   X=1,999
+
+      do jj = 1, 999
+      if (jj.lt.10) then
+         write(keynum,'(I1)')jj
+      else if (jj.lt.100) then
+         write(keynum,'(I2)')jj
+      else
+         write(keynum,'(I3)')jj
+      endif
+      keyword = 'OCCDIR'//keynum
+
+      CALL RDATAB(LOPEN,'INCAR',IU5, keyword ,'=','#',';','F', &
+     &   IDUM,FTMP,CDUM,LDUM,CHARAC,N,NDIM,IERR)
+
+         IF ((IERR/=0) .AND. (IERR/=3)) THEN
+            WRITE(IU6,*) " "
+            WRITE(IU6,'("Error in ",a9," format. Format should be")') keyword
+            WRITE(IU6,*)"'No of atoms, No * (ATOM, LDAUL, &
+        &               No of elements, No of E *( i, j, spin, occ))"
+            WRITE(IU6,*)" Everything else will be set to zero !"
+            STOP
+         ENDIF
+
+        IF (IERR==0) then
+
+          IF(IU6>0)  then
+            WRITE(IU6,*) " "
+            WRITE(IU6,'(" ",a9," found ")') keyword
+!            WRITE(IU6,*)'No of atoms, No * (ATOM, LDAUL, &
+!                  & No of elements, No of E *( i, j, spin, occ))'
+!            WRITE(IU6,*)' i and j vary from 1 - 16. &
+!                  & 1:s, 2-4:p, 5-9:d, 10-16:f'
+!            WRITE(IU6,*)' Everything else will be set to zero !'
+          endif
+
+         OCC_PNATOMS = OCC_NATOMS
+         OCC_NATOMS = OCC_PNATOMS + INT(FTMP(1))
+         j=1
+         do i = OCC_PNATOMS+1, OCC_NATOMS
+            ATOM_OCC(i) = INT(FTMP(1+j))
+            ATOM_L(i)   = INT(FTMP(2+j))
+            NUM_ORB     = INT(FTMP(3+j))
+
+            do ii = 1, NUM_ORB
+                 i1 = FTMP(4+j+(ii-1)*4)
+                 i2 = FTMP(5+j+(ii-1)*4)
+                 is = FTMP(6+j+(ii-1)*4)
+#ifdef realmode
+                 OCC_MAT_INPUT(i1,i2,is,ATOM_OCC(i)) = FTMP(7+j+(ii-1)*4)
+#else
+                 OCC_MAT_INPUT(i1,i2,is,ATOM_OCC(i)) = CMPLX( FTMP(7+j+(ii-1)*4), 0, q)
+#endif
+            enddo
+
+          j = j + 3 + NUM_ORB*4
+
+          enddo
+
+        ENDIF
+
+       ENDDO
+
+! end of OCCDIRXXX input
+!-----------------------------------
+! alternative matrix input from external file OCCMATRIX
+
+              CALL RDATAB(LOPEN,'INCAR',IU5,'OCCEXT','=','#',';','I', &
+     &   ITMP,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+
+         if((IERR/=0) .AND. (IERR/=3)) THEN
+            write(IU6,*) " "
+            write(IU6,'(" Error in OCCEXT format. Format is in the occupation matrix documentation")')
+            write(IU6,*) " "
+            write(IU6,*) " "
+            stop
+         endif
+
+        if(ITMP==1.and.IERR==0) then
+          If(IU6>0)  then
+            write(IU6,*) " "
+            write(IU6,'(" OCCEXT found - reading occupation matrix from external file OCCMATRIX")')
+            write(IU6,*) " "
+          endif
+
+        open(unit=999,file='OCCMATRIX',status='OLD')
+
+        read(999,*) occ_natoms
+
+        do i=1,occ_natoms
+         read(999,*) atom_occ(i), atom_l(i), occ_spin
+         read(999,*)
+         NUM_ORB     = 2*ATOM_L(i)+1
+!         if(IU6>0) WRITE(IU6,*) "ATOM ",ATOM_OCC(i)," L = ",ATOM_L(i)," NUM = ",NUM_ORB
+
+! calculate start point in matrix from summing the number of orbitals for
+! angular momentum less that that of interest
+         START = 0
+         do ii = ATOM_L(i)-1, 0, -1
+           START = START + 2*ii+1
+         enddo
+         START = START+1
+         do i1 = START, START + NUM_ORB-1
+
+           read(999,*) (FTMP(i2), i2=start, start+num_orb-1 )
+!           read(999,*) (OCC_MAT_INPUT(i1,i2,1,ATOM_OCC(i)), i2=start, start+num_orb-1 )
+
+#ifdef realmode
+
+           do i2 = start, start+num_orb-1
+              OCC_MAT_INPUT(i1,i2,1,ATOM_OCC(i))=FTMP(i2)
+           enddo
+#else
+           do i2 = start, start+num_orb-1
+              OCC_MAT_INPUT(i1,i2,1,ATOM_OCC(i))=CMPLX (FTMP(i2), 0, q)
+           enddo
+#endif
+
+         enddo
+
+         if(occ_spin==2) then
+           read(999,*)
+           do i1 = start, start+num_orb-1
+
+           read(999,*) (FTMP(i2), i2=start, start+num_orb-1 )
+!           read(999,*) (OCC_MAT_INPUT(i1,i2,2,ATOM_OCC(i)), i2=start, start+num_orb-1 )
+
+#ifdef realmode
+             do i2 = start, start+num_orb-1
+                OCC_MAT_INPUT(i1,i2,2,ATOM_OCC(i))=FTMP(i2)
+             enddo
+#else
+             do i2 = start, start+num_orb-1
+                OCC_MAT_INPUT(i1,i2,2,ATOM_OCC(i))=CMPLX (FTMP(i2), 0, q)
+             enddo
+#endif
+
+           enddo
+         endif
+
+         read(999,*)
+
+        enddo
+
+
+        endif
+
+
+! end of matrix input
+!-----------------------------------
+! write out occupation matrices - first spin up then spin down
+
+       IF(IU6>0) THEN
+         WRITE(IU6,*) " "
+         WRITE(IU6,*) "Occupation matrix control coded by Prof. Graeme Watson "
+         write(IU6,*) "at Trinity College Dublin"
+         WRITE(IU6,*) " "
+         WRITE(IU6,*) "Occupation set for the following atoms "
+         WRITE(IU6,*) " "
+
+       do ii = 1,OCC_NATOMS
+         WRITE(IU6,*) "ATOM ",ATOM_OCC(ii)," Spin up "
+         WRITE(IU6,*) " "
+         WRITE(IU6,"(4X,16(2X,I2,2X))") (j, j=1,16)
+        do i = 1,16
+
+#ifdef realmode
+         WRITE(IU6,"((I2,2X, 16(F5.2,X),2X,I2))") i,  &
+                    & (OCC_MAT_INPUT(i,j,1,ATOM_OCC(ii)), j=1,16) ,i
+#else
+         WRITE(IU6,"((I2,2X, 16(F5.2,X),2X,I2))") i,  &
+                    & ( real( OCC_MAT_INPUT(i,j,1,ATOM_OCC(ii)) ), j=1,16) ,i
+
+#endif
+        enddo
+         WRITE(IU6,"(4X,16(2X,I2,2X))") (j, j=1,16)
+         WRITE(IU6,*) " "
+         WRITE(IU6,*) "ATOM ",ATOM_OCC(ii)," Spin down "
+         WRITE(IU6,*) " "
+         WRITE(IU6,"(4X,16(2X,I2,2X))") (j, j=1,16)
+        do i = 1,16
+
+#ifdef realmode
+         WRITE(IU6,"(I2,2X, 16(F5.2,X),2X,I2)") i,  &
+                    & (OCC_MAT_INPUT(i,j,2,ATOM_OCC(ii)), j=1,16) ,i
+#else
+         WRITE(IU6,"(I2,2X, 16(F5.2,X),2X,I2)") i,  &
+                    & ( real( OCC_MAT_INPUT(i,j,2,ATOM_OCC(ii)) ), j=1,16) ,i
+#endif
+        enddo
+         WRITE(IU6,"(4X,16(2X,I2,2X))") (j, j=1,16)
+       enddo
+      ENDIF
+
+
+! Close INCAR
+
+         CLOSE(IU5)
+
+! END GWW
+
+!-----------------------------------------------------------------------------------------------------
+
+      RETURN
+      END SUBROUTINE INITIALIZE_LDAU
 
 
 !**********************************************************************
@@ -251,12 +497,12 @@
          WRITE(IU6,120) U
          WRITE(IU6,130) J
       ENDIF
-      
+
   100 FORMAT(' LDA+U is selected, type is set to LDAUTYPE = ',I2)
   110 FORMAT('   angular momentum for each species LDAUL = ',20I5)
   120 FORMAT('   U (eV)           for each species LDAUU = ',20F5.1)
   130 FORMAT('   J (eV)           for each species LDAUJ = ',20F5.1)
-       
+
       END SUBROUTINE WRITE_LDApU
 
 
@@ -269,17 +515,17 @@
       SUBROUTINE XML_WRITE_LDAU
       USE pseudo
       IMPLICIT NONE
- 
+
       LOGICAL :: LDUM
       INTEGER :: IDUM
       REAL(q) :: RDUM
       COMPLEX(q)  :: CDUM
       CHARACTER (1) :: CHARAC
- 
+
       CALL XML_INCAR('LDAU','L',IDUM,RDUM,CDUM,TLDA_U,CHARAC,1)
 
       IF (.NOT.TLDA_U) RETURN
- 
+
       CALL XML_INCAR_V('LDAUTYPE','I',TYPE_POT,RDUM,CDUM,LDUM,CHARAC,1)
       CALL XML_INCAR_V('LDAUL','I',LANG_LDAPLUSU,RDUM,CDUM,LDUM,CHARAC,1)
       CALL XML_INCAR_V('LDAUU','F',IDUM,U,CDUM,LDUM,CHARAC,1)
@@ -337,25 +583,25 @@
 
       FUNCTION LCALC_ORBITAL_MOMENT()
       LOGICAL LCALC_ORBITAL_MOMENT
-      
+
       LCALC_ORBITAL_MOMENT=LORBMOM
-      
+
       END FUNCTION LCALC_ORBITAL_MOMENT
 
 !**********************************************************************
 !
-!  This routine calculates the occupancy matrix, i.e., how many 
+!  This routine calculates the occupancy matrix, i.e., how many
 !  electrons are in each lm (OCC_MAT), the corrections to the strength
 !  parameters CDIJ, and the double counting energy DBLE_LDAU.
 !
 !  presently the atom number is also handled down (IATOM)
-!  but not used (it could be used to kick the system into a 
+!  but not used (it could be used to kick the system into a
 !  particular state)
 !
 !**********************************************************************
 
       SUBROUTINE LDAPLUSU(LMDIM,IATOM,ITYP,CRHODE,CDIJ,PP,DBLE_LDAU)
-    
+
       USE pseudo
       USE poscar
       USE radial
@@ -363,11 +609,11 @@
       IMPLICIT NONE
 
       TYPE(potcar) PP  ! pseudopotential descriptor
-            
+
       INTEGER LMDIM
       INTEGER IATOM
       INTEGER ITYP
-      
+
       REAL(q) DBLE_LDAU
 
       OVERLAP CRHODE(LMDIM,LMDIM,NCDIJ) ! occupancy matrix
@@ -375,11 +621,15 @@
 
       INTEGER ISP,LN1,LN2,LMN1,LMN2,L1,L2,M1,M2,LM1,LM2
       INTEGER LNMAX,LMMAX
+!GWW
+      INTEGER :: I, II, jj, START
+!GWW END
+
 
       DBLE_LDAU=0._q
       OCC_MAT=0._q
       OCC_MAT_ALL(:,:,:,IATOM)=0._q
-      
+
       ! quick return if possible
       DO LN1=1,PP%LMAX
          IF (PP%LPS(LN1)==LANG_LDAPLUSU(ITYP)) GOTO 100
@@ -387,19 +637,19 @@
       RETURN
 
   100 CONTINUE
-                                             
+
 !===================================================================
-!  OCC(LM1,LM2) = SUM_{nk} f_nk <PSI_nk|Y_lm1> > <Y_lm2|PSI_nk> 
+!  OCC(LM1,LM2) = SUM_{nk} f_nk <PSI_nk|Y_lm1> > <Y_lm2|PSI_nk>
 !  WITH
-!  |PSI_NK> = SUM_{lmn3} <~P_{lmn3|~PSI_nk>  |PHI_lmn3> 
+!  |PSI_NK> = SUM_{lmn3} <~P_{lmn3|~PSI_nk>  |PHI_lmn3>
 !
-!  OCC(LM1,LM2) = SUM_{lmna,lmnb} delta(lma,lm1)*delta(lmb,lm2) 
+!  OCC(LM1,LM2) = SUM_{lmna,lmnb} delta(lma,lm1)*delta(lmb,lm2)
 !                 RHO_{lmna,lmnb} * <PHI_{ln1}|PHI_{ln2}>
 !
 !  LM =  (1)    (2   3   4)      (5    6     7      8     9)
 !        (s)   (p_y p_z p_x)   (d_xy d_yz d_z2-r2 d_xz d_x2-y2)
 !===================================================================
-              
+
       LNMAX=PP%LMAX
       LMMAX=(MAXVAL(PP%LPS(1:LNMAX))+1)**2
 
@@ -430,23 +680,45 @@
 !     ENDIF
 ! test
 
+! GWW Set Occupation Matrix for Atoms input
+
+          do i = 1,OCC_NATOMS
+
+             if(ATOM_OCC(i)/=IATOM) CYCLE
+             START = 0
+             do ii = ATOM_L(i)-1, 0, -1
+                START = START + 2*ii+1
+             enddo
+             START = START+1
+             do ii = START, START + ATOM_L(i)*2
+                do jj = START, START + ATOM_L(i)*2
+                    OCC_MAT(ii,jj,1)=OCC_MAT_INPUT(ii,jj,1,ATOM_OCC(i))
+                    OCC_MAT(ii,jj,2)=OCC_MAT_INPUT(ii,jj,2,ATOM_OCC(i))
+                enddo
+             enddo
+
+          enddo
+
+! GWW
+
+
       OCC_MAT_ALL(:,:,:,IATOM)=OCC_MAT(:,:,:)
-      
+
 !==============================================================
-!        choose lda+u potential type                   
-! TYPE1: presently not supported           
+!        choose lda+u potential type
+! TYPE1: presently not supported
 ! TYPE2: use only  U and J
 !==============================================================
 
-      IF (TYPE_POT == 1) THEN 
-         CALL POT_TYPE1(LMDIM,IATOM,ITYP,LNMAX,PP%LPS,CRHODE,CDIJ,DBLE_LDAU) 
-      ELSEIF (TYPE_POT == 2) THEN  
+      IF (TYPE_POT == 1) THEN
+         CALL POT_TYPE1(LMDIM,IATOM,ITYP,LNMAX,PP%LPS,CRHODE,CDIJ,DBLE_LDAU)
+      ELSEIF (TYPE_POT == 2) THEN
          CALL POT_TYPE2(LMDIM,IATOM,ITYP,LNMAX,PP%LPS,CRHODE,CDIJ,DBLE_LDAU)
       ELSEIF (TYPE_POT == 3) THEN
          CALL POT_TYPE3(LMDIM,IATOM,ITYP,LNMAX,PP%LPS,CRHODE,CDIJ,DBLE_LDAU)
-      ELSEIF (TYPE_POT == 4) THEN 
+      ELSEIF (TYPE_POT == 4) THEN
          CALL POT_TYPE4(LMDIM,IATOM,ITYP,LNMAX,PP%LPS,CRHODE,CDIJ,DBLE_LDAU)
-      ELSEIF (TYPE_POT == 5) THEN 
+      ELSEIF (TYPE_POT == 5) THEN
          CALL POT_TYPE5(LMDIM,IATOM,ITYP,LNMAX,PP%LPS,CDIJ,DBLE_LDAU)
       ENDIF
 
@@ -456,28 +728,28 @@
 
 !**********************************************************************
 !
-!  calculate the radial integral (ae_phi_i | ae_phi_j) for all 
+!  calculate the radial integral (ae_phi_i | ae_phi_j) for all
 !  lm(n)-states
 !
 !**********************************************************************
 
       SUBROUTINE OVERLAP_AE(R,RDEP,ITYP,NTYP,LNMAX,WAE,L_OF_LN)
-      
+
       USE radial
-      
+
       IMPLICIT NONE
 
       TYPE (rgrid) R
-      
+
       INTEGER ITYP,NTYP
       INTEGER LNMAX
       REAL(q) :: RDEP
       REAL(q) WAE(:,:)       ! AE partial wavefunctions
       INTEGER L_OF_LN(LNMAX) ! l quantum number per channel
-          
+
 ! local variables
       INTEGER LN1,LN2
-      INTEGER IR,IRMAX 
+      INTEGER IR,IRMAX
       INTEGER L1,L2
 
       REAL(q) RES
@@ -494,7 +766,7 @@
       ! quantum numbers l1 and l2 of these two channels ln1 and ln2
          L1=L_OF_LN(LN1)
          L2=L_OF_LN(LN2)
-         IF (L1 /= L2) CYCLE 
+         IF (L1 /= L2) CYCLE
 
 !        IRMAX=R%NMAX
          RHOT=0._q
@@ -519,36 +791,36 @@
 !**********************************************************************
 
       SUBROUTINE POT_TYPE1(LMDIM,IATOM,ITYP,LNMAX,L_OF_LN,CRHODE,CDIJ,DBLE_LDAU)
-      
+
       IMPLICIT NONE
-      
+
       INTEGER LMDIM
       INTEGER IATOM
       INTEGER ITYP
       INTEGER LNMAX,LMMAX
       INTEGER L_OF_LN(LNMAX)
-      
+
       REAL(q) DBLE_LDAU
-      
+
       OVERLAP CRHODE(LMDIM,LMDIM,NCDIJ)
       OVERLAP CDIJ(LMDIM,LMDIM,NCDIJ)
-   
+
       INTEGER LN1,LN2,LMN1,LMN2,LM1,LM2,LM3,LM4
       INTEGER L1,L2,M1,M2,M3,M4
       INTEGER ISP
-      
+
       REAL(q) DC1,DC2,DC3
       REAL(q) M,M_x,M_y,M_z,NEL,NUP,NDW
-      
+
       OVERLAP POT_U(LMDIM,LMDIM,NCDIJ),TMP
-      
+
       LMMAX=(MAXVAL(L_OF_LN(1:LNMAX))+1)**2
 
-      CALL COULOMB_INTERACTION(ITYP)      
-            
+      CALL COULOMB_INTERACTION(ITYP)
+
       DC1=0._q
       POT_U=0._q
-            
+
       LMN1=0
       DO LN1=1,LNMAX
       L1=L_OF_LN(LN1)
@@ -563,9 +835,9 @@
          DO M2=1,2*L2+1
             LMN2=LMN2+1
             IF (L2 /= LANG_LDAPLUSU(ITYP)) CYCLE
-           
+
             LM2=L2**2+M2
-         
+
             DO ISP=1,NCDIJ
                TMP=0._q
                IF (ISP==1.OR.ISP==NCDIJ) THEN
@@ -582,7 +854,7 @@
                      ! -U * \Sum_m (\rho^{\alpha\alpha}_mm+\rho^{\beta\beta}_mm)
                      ! +J * \Sum_m (\rho^{isp isp}_mm)
                      IF (LM1==LM2.AND.LM3==LM4) THEN
-                        TMP=TMP-U(ITYP)*(OCC_MAT(LM4,LM3,1)+OCC_MAT(LM4,LM3,NCDIJ))+J(ITYP)*OCC_MAT(LM4,LM3,ISP)                   
+                        TMP=TMP-U(ITYP)*(OCC_MAT(LM4,LM3,1)+OCC_MAT(LM4,LM3,NCDIJ))+J(ITYP)*OCC_MAT(LM4,LM3,ISP)
                      ENDIF
                   ENDDO ! M4
                   ENDDO ! M3
@@ -595,7 +867,7 @@
                   LM3=LANG_LDAPLUSU(ITYP)**2+M3
                   DO M4=1,2*LANG_LDAPLUSU(ITYP)+1
                   LM4=LANG_LDAPLUSU(ITYP)**2+M4
-                     ! Fock term 
+                     ! Fock term
                      TMP=TMP-V(M1,M3,M4,M2)*OCC_MAT(LM4,LM3,ISP)
                      ! Terms arising from the definition of the double counting energy
                      ! +J * \Sum_m (\rho^{\alpha\beta c.q. \beta\alpha}_mm)
@@ -603,21 +875,21 @@
                         TMP=TMP+J(ITYP)*OCC_MAT(LM4,LM3,ISP)
                      ENDIF
                   ENDDO ! M4
-                  ENDDO ! M3                  
+                  ENDDO ! M3
                ENDIF
 
                POT_U(LMN1,LMN2,ISP)=TMP*OVERLAP_AE_(LN1,LN2,ITYP)
 
                ! To calculate the double counting corrections to
                ! the total energy as calculated from the eigenvalues
-#ifndef realmode               
+#ifndef realmode
                DC1=DC1+POT_U(LMN1,LMN2,ISP)*CONJG(CRHODE(LMN1,LMN2,ISP))
 #else
                DC1=DC1+POT_U(LMN1,LMN2,ISP)*CRHODE(LMN1,LMN2,ISP)
 #endif
-               
+
             ENDDO ! ISP
-                  
+
          ENDDO ! M2
          ENDDO ! LN2
       ENDDO ! M1
@@ -630,7 +902,7 @@
 !     IF (PRINTOCC>1) THEN
       IF (.FALSE.) THEN
 !     IF (IATOM==1) THEN
-! test      
+! test
          WRITE(*,*) 'potential matrix for atom',IATOM
          DO ISP=1,NCDIJ
          WRITE(*,*) 'component',ISP
@@ -649,7 +921,7 @@
          WRITE(*,*)
          WRITE(*,*) 'Hamilton matrix for atom',IATOM
          DO ISP=1,NCDIJ
-         WRITE(*,*) 'component',ISP         
+         WRITE(*,*) 'component',ISP
          DO LMN1=1,10
             WRITE(*,'(10F12.6)') (REAL(CDIJ(LMN1,LMN2,ISP)),LMN2=1,10)
          ENDDO
@@ -658,7 +930,7 @@
          DO LMN1=1,10
             WRITE(*,'(10F12.6)') (AIMAG(CDIJ(LMN1,LMN2,ISP)),LMN2=1,10)
          ENDDO
-         WRITE(*,*)   
+         WRITE(*,*)
 #endif
          ENDDO
       ENDIF
@@ -666,7 +938,7 @@
 ! #endif
 ! test
 
-! Calculate the remaining terms necessary to determine the 
+! Calculate the remaining terms necessary to determine the
 ! double counting correction to the total energy as calculated
 ! from the eigenvalues
 
@@ -682,7 +954,7 @@
          LM3=LANG_LDAPLUSU(ITYP)**2+M3
          DO M4=1,2*LANG_LDAPLUSU(ITYP)+1
          LM4=LANG_LDAPLUSU(ITYP)**2+M4
-      
+
          IF (ISP==1.OR.ISP==NCDIJ) THEN
          ! diagonal terms
             ! Hartree energy
@@ -697,23 +969,23 @@
             DC2=DC2-V(M1,M3,M4,M2)*CONJG(OCC_MAT(LM1,LM2,ISP))*OCC_MAT(LM4,LM3,ISP)/2
 #endif
          ENDIF
-      
+
          ENDDO ! M4
          ENDDO ! M3
       ENDDO ! M2
       ENDDO ! M1
 
-      ENDDO ! ISP      
-      
+      ENDDO ! ISP
+
       DC3=0._q
       NEL=0._q ; M_x=0._q ; M_y=0._q ; M_z=0._q ; M=0._q
-      
+
       DO M1=1,2*LANG_LDAPLUSU(ITYP)+1
       LM1=LANG_LDAPLUSU(ITYP)**2+M1
-      
+
          NEL=NEL+OCC_MAT(LM1,LM1,1)+OCC_MAT(LM1,LM1,NCDIJ)
          M_z=M_z+OCC_MAT(LM1,LM1,1)-OCC_MAT(LM1,LM1,NCDIJ)
-      
+
 #ifndef realmode
          IF (NCDIJ==4) THEN
             M_x=M_x+2*REAL(OCC_MAT(LM1,LM1,2))
@@ -721,20 +993,20 @@
          ENDIF
 #endif
       ENDDO ! M1
-      
+
       M=M_z
       IF (NCDIJ==4) THEN
          M=SQRT(M_x*M_x+M_y*M_y+M_z*M_z)
       ENDIF
-      
+
       NUP=(NEL+M)/2
       NDW=(NEL-M)/2
-            
+
       DC3=U(ITYP)*NEL*(NEL-1)/2-J(ITYP)*(NUP*(NUP-1)+NDW*(NDW-1))/2
-      
+
       DBLE_LDAU=DC2-DC1-DC3
 
-#ifndef MPI            
+#ifndef MPI
       IF (PRINTOCC /= 0) THEN
          WRITE(*,*) 'LDA+U energy corrections',IATOM
          WRITE(*,*) '==================================='
@@ -743,8 +1015,8 @@
          WRITE(*,*) ' E(eignv.) =',-DC1
          WRITE(*,*) ' DBLE_LDAU =',DBLE_LDAU
       ENDIF
-#endif      
-      
+#endif
+
       RETURN
       END SUBROUTINE POT_TYPE1
 
@@ -756,36 +1028,36 @@
 !**********************************************************************
 
       SUBROUTINE POT_TYPE4(LMDIM,IATOM,ITYP,LNMAX,L_OF_LN,CRHODE,CDIJ,DBLE_LDAU)
-      
+
       IMPLICIT NONE
-      
+
       INTEGER LMDIM
       INTEGER IATOM
       INTEGER ITYP
       INTEGER LNMAX,LMMAX
       INTEGER L_OF_LN(LNMAX)
-      
+
       REAL(q) DBLE_LDAU
-      
+
       OVERLAP CRHODE(LMDIM,LMDIM,NCDIJ)
       OVERLAP CDIJ(LMDIM,LMDIM,NCDIJ)
-   
+
       INTEGER LN1,LN2,LMN1,LMN2,LM1,LM2,LM3,LM4
       INTEGER L1,L2,M1,M2,M3,M4
       INTEGER ISP
-      
+
       REAL(q) DC1,DC2,DC3
       REAL(q) NEL
-      
+
       OVERLAP POT_U(LMDIM,LMDIM,NCDIJ),TMP
-      
+
       LMMAX=(MAXVAL(L_OF_LN(1:LNMAX))+1)**2
 
-      CALL COULOMB_INTERACTION(ITYP)      
-            
+      CALL COULOMB_INTERACTION(ITYP)
+
       DC1=0._q
       POT_U=0._q
-            
+
       LMN1=0
       DO LN1=1,LNMAX
       L1=L_OF_LN(LN1)
@@ -800,9 +1072,9 @@
          DO M2=1,2*L2+1
             LMN2=LMN2+1
             IF (L2 /= LANG_LDAPLUSU(ITYP)) CYCLE
-           
+
             LM2=L2**2+M2
-         
+
             DO ISP=1,NCDIJ
                TMP=0._q
                IF (ISP==1.OR.ISP==NCDIJ) THEN
@@ -819,7 +1091,7 @@
                      ! -U * \Sum_m (\rho^{\alpha\alpha}_mm+\rho^{\beta\beta}_mm)
                      ! +J * \Sum_m (\rho^{isp isp}_mm)
                      IF (LM1==LM2.AND.LM3==LM4) THEN
-                        TMP=TMP-(U(ITYP)-J(ITYP)/2)*(OCC_MAT(LM4,LM3,1)+OCC_MAT(LM4,LM3,NCDIJ))                   
+                        TMP=TMP-(U(ITYP)-J(ITYP)/2)*(OCC_MAT(LM4,LM3,1)+OCC_MAT(LM4,LM3,NCDIJ))
                      ENDIF
                   ENDDO ! M4
                   ENDDO ! M3
@@ -832,24 +1104,24 @@
                   LM3=LANG_LDAPLUSU(ITYP)**2+M3
                   DO M4=1,2*LANG_LDAPLUSU(ITYP)+1
                   LM4=LANG_LDAPLUSU(ITYP)**2+M4
-                     ! Fock term 
+                     ! Fock term
                      TMP=TMP-V(M1,M3,M4,M2)*OCC_MAT(LM4,LM3,ISP)
                   ENDDO ! M4
-                  ENDDO ! M3                  
+                  ENDDO ! M3
                ENDIF
 
                POT_U(LMN1,LMN2,ISP)=TMP*OVERLAP_AE_(LN1,LN2,ITYP)
 
                ! To calculate the double counting corrections to
                ! the total energy as calculated from the eigenvalues
-#ifndef realmode               
+#ifndef realmode
                DC1=DC1+POT_U(LMN1,LMN2,ISP)*CONJG(CRHODE(LMN1,LMN2,ISP))
 #else
                DC1=DC1+POT_U(LMN1,LMN2,ISP)*CRHODE(LMN1,LMN2,ISP)
 #endif
-               
+
             ENDDO ! ISP
-                  
+
          ENDDO ! M2
          ENDDO ! LN2
       ENDDO ! M1
@@ -877,7 +1149,7 @@
          WRITE(*,*)
          WRITE(*,*) 'Hamilton matrix for atom',IATOM
          DO ISP=1,NCDIJ
-         WRITE(*,*) 'component',ISP         
+         WRITE(*,*) 'component',ISP
          DO LMN1=1,10
             WRITE(*,'(10F12.6)') (REAL(CDIJ(LMN1,LMN2,ISP)),LMN2=1,LMDIM)
          ENDDO
@@ -886,13 +1158,13 @@
          DO LMN1=1,10
             WRITE(*,'(10F12.6)') (AIMAG(CDIJ(LMN1,LMN2,ISP)),LMN2=1,LMDIM)
          ENDDO
-         WRITE(*,*)   
+         WRITE(*,*)
 #endif
          ENDDO
       ENDIF
 #endif
 
-! Calculate the remaining terms necessary to determine the 
+! Calculate the remaining terms necessary to determine the
 ! double counting correction to the total energy as calculated
 ! from the eigenvalues
 
@@ -908,7 +1180,7 @@
          LM3=LANG_LDAPLUSU(ITYP)**2+M3
          DO M4=1,2*LANG_LDAPLUSU(ITYP)+1
          LM4=LANG_LDAPLUSU(ITYP)**2+M4
-      
+
          IF (ISP==1.OR.ISP==NCDIJ) THEN
          ! diagonal terms
             ! Hartree energy
@@ -923,27 +1195,27 @@
             DC2=DC2-V(M1,M3,M4,M2)*CONJG(OCC_MAT(LM1,LM2,ISP))*OCC_MAT(LM4,LM3,ISP)/2
 #endif
          ENDIF
-      
+
          ENDDO ! M4
-         ENDDO ! M3 
+         ENDDO ! M3
       ENDDO ! M2
       ENDDO ! M1
 
-      ENDDO ! ISP      
-      
+      ENDDO ! ISP
+
       DC3=0._q
       NEL=0._q
-      
+
       DO M1=1,2*LANG_LDAPLUSU(ITYP)+1
       LM1=LANG_LDAPLUSU(ITYP)**2+M1
           NEL=NEL+OCC_MAT(LM1,LM1,1)+OCC_MAT(LM1,LM1,NCDIJ)
       ENDDO ! M1
-      
+
       DC3=U(ITYP)*NEL*(NEL-1)/2-J(ITYP)*NEL*(NEL-2)/4
-      
+
       DBLE_LDAU=DC2-DC1-DC3
 
-#ifndef MPI            
+#ifndef MPI
       IF (PRINTOCC /= 0) THEN
          WRITE(*,*) 'LDA+U energy corrections',IATOM
          WRITE(*,*) '==================================='
@@ -956,8 +1228,8 @@
 
       RETURN
       END SUBROUTINE POT_TYPE4
-      
-                                                             
+
+
 !**********************************************************************
 !
 ! LDAUTYPE=2
@@ -986,7 +1258,7 @@
       INTEGER LN1,LN2,LMN1,LMN2,LM1,LM2,LMSTART,LMSTOP
       INTEGER L1,L2,M1,M2
       INTEGER ISP
-      
+
       REAL(q) DC,DC_
 
       OVERLAP POT_U(LMDIM,LMDIM,NCDIJ),TMP
@@ -994,7 +1266,7 @@
 !=======================================================================
 
       LMMAX=(MAXVAL(L_OF_LN(1:LNMAX))+1)**2
-                                                           
+
 !-----------------------------------------------------------------------
 !    loop of potential V(LMN1,LMN2)
 !-----------------------------------------------------------------------
@@ -1016,10 +1288,10 @@
          DO M2=1,2*L2+1
             LMN2=LMN2+1
             IF (L2 /= LANG_LDAPLUSU(ITYP)) CYCLE
-           
+
             LM2=L2**2+M2
-            
-            DO ISP=1,NCDIJ                                                       
+
+            DO ISP=1,NCDIJ
                TMP= -1._q*(U(ITYP)-J(ITYP))*OCC_MAT(LM1,LM2,ISP)
 
                IF (M1==M2.AND.(ISP==1.OR.ISP==NCDIJ)) THEN
@@ -1028,7 +1300,7 @@
 
                POT_U(LMN1,LMN2,ISP) = TMP*OVERLAP_AE_(LN1,LN2,ITYP)
 
-               ! double counting correction 
+               ! double counting correction
 #ifndef realmode
                DC=DC+POT_U(LMN1,LMN2,ISP)*CONJG(CRHODE(LMN1,LMN2,ISP))
 #else
@@ -1039,24 +1311,24 @@
          ENDDO !(LN2)
       ENDDO !(M1)
       ENDDO !(LN1)
-      
+
 !=======================================================================
 ! add LDA+U correction to hamiltonian CDIJ
 !=======================================================================
-                                                          
+
       CDIJ=CDIJ+POT_U
 
 !=======================================================================
 ! LDA+U double counting corrections
 ! Eq. (7) of  Dudarev PRB 57, 1505
 !=======================================================================
-                                                            
+
 !-----------------------------------------------------------------------
-! LDA+U - LSDA contribution    
+! LDA+U - LSDA contribution
 !-----------------------------------------------------------------------
 
       DC_=0._q
-      
+
       LMSTART=LANG_LDAPLUSU(ITYP)**2+1
       LMSTOP=(LANG_LDAPLUSU(ITYP)+1)**2
 
@@ -1064,9 +1336,9 @@
       DO LM1=LMSTART,LMSTOP
       DO LM2=LMSTART,LMSTOP
 #ifndef realmode
-         DC_=DC_-0.5_q*(U(ITYP)-J(ITYP))*OCC_MAT(LM1,LM2,ISP)*CONJG(OCC_MAT(LM1,LM2,ISP))            
+         DC_=DC_-0.5_q*(U(ITYP)-J(ITYP))*OCC_MAT(LM1,LM2,ISP)*CONJG(OCC_MAT(LM1,LM2,ISP))
 #else
-         DC_=DC_-0.5_q*(U(ITYP)-J(ITYP))*OCC_MAT(LM1,LM2,ISP)*OCC_MAT(LM2,LM1,ISP)            
+         DC_=DC_-0.5_q*(U(ITYP)-J(ITYP))*OCC_MAT(LM1,LM2,ISP)*OCC_MAT(LM2,LM1,ISP)
 #endif
          IF (LM1==LM2.AND.(ISP==1.OR.ISP==NCDIJ)) THEN
             DC_=DC_+0.5_q*(U(ITYP)-J(ITYP))*OCC_MAT(LM1,LM1,ISP)
@@ -1074,7 +1346,7 @@
       ENDDO !(LM1)
       ENDDO !(LM2)
       ENDDO !(ISP)
-     
+
 !-----------------------------------------------------------------------
       DBLE_LDAU=DC_-DC
 
@@ -1097,7 +1369,7 @@
 !**********************************************************************
 
       SUBROUTINE POT_TYPE3(LMDIM,IATOM,ITYP,LNMAX,L_OF_LN,CRHODE,CDIJ,DBLE_LDAU)
-      
+
       IMPLICIT NONE
 
       INTEGER LMDIM
@@ -1114,7 +1386,7 @@
       INTEGER LN1,LN2,LMN1,LMN2,LM1,LM2,LMSTART,LMSTOP
       INTEGER L1,L2,M1,M2
       INTEGER ISP
-      
+
       REAL(q) DC
       REAL(q) M,M_x,M_y,M_z,NEL,NUP,NDW
       REAL(q) V(NCDIJ)
@@ -1123,11 +1395,11 @@
 
       DC=0._q
       POT_U=0._q
-      
+
       V=0._q
       V(1)=U(ITYP)
       IF (NCDIJ/=1) V(NCDIJ)=J(ITYP)
-      
+
       LMN1=0
       DO LN1=1,LNMAX
       L1=L_OF_LN(LN1)
@@ -1142,13 +1414,13 @@
          DO M2=1,2*L2+1
             LMN2=LMN2+1
             IF (L2 /= LANG_LDAPLUSU(ITYP)) CYCLE
-           
+
             LM2=L2**2+M2
-            
-            DO ISP=1,NCDIJ,NCDIJ-1                                                       
+
+            DO ISP=1,NCDIJ,NCDIJ-1
                IF (L1==L2.AND.M1==M2) THEN
                   POT_U(LMN1,LMN2,ISP) = -1._q*V(ISP)*OVERLAP_AE_(LN1,LN2,ITYP)
-                  ! energy correction 
+                  ! energy correction
 #ifndef realmode
                   DC=DC+POT_U(LMN1,LMN2,ISP)*CONJG(CRHODE(LMN1,LMN2,ISP))
 #else
@@ -1163,7 +1435,7 @@
 
       CDIJ=CDIJ+POT_U
 !=======================================================================
-!   test printout                    
+!   test printout
 !=======================================================================
 #ifndef MPI
       IF (PRINTOCC>1) THEN
@@ -1188,7 +1460,7 @@
          WRITE(*,*)
          WRITE(*,*) 'Hamilton matrix for atom',IATOM
          DO ISP=1,NCDIJ
-         WRITE(*,*) 'component',ISP         
+         WRITE(*,*) 'component',ISP
          DO LMN1=1,LMDIM
             WRITE(*,*) 'lmn',LMN1
 #ifndef realmode
@@ -1200,21 +1472,21 @@
             WRITE(*,'(20F8.2)') (AIMAG(CDIJ(LMN1,LMN2,ISP)),LMN2=1,LMDIM)
 #endif
          ENDDO
-         WRITE(*,*)   
+         WRITE(*,*)
          ENDDO
       ENDIF
-#endif            
+#endif
 !     DBLE_LDAU=-DC
       DBLE_LDAU=0._q
 
       NEL=0._q ; M_x=0._q ; M_y=0._q ; M_z=0._q ; M=0._q
-      
+
       DO M1=1,2*LANG_LDAPLUSU(ITYP)+1
       LM1=LANG_LDAPLUSU(ITYP)**2+M1
-      
+
          NEL=NEL+OCC_MAT(LM1,LM1,1)+OCC_MAT(LM1,LM1,NCDIJ)
          M_z=M_z+OCC_MAT(LM1,LM1,1)-OCC_MAT(LM1,LM1,NCDIJ)
-      
+
 #ifndef realmode
          IF (NCDIJ==4) THEN
             M_x=M_x+2*REAL(OCC_MAT(LM1,LM1,2))
@@ -1222,12 +1494,12 @@
          ENDIF
 #endif
       ENDDO ! M1
-      
+
       M=M_z
       IF (NCDIJ==4) THEN
          M=SQRT(M_x*M_x+M_y*M_y+M_z*M_z)
       ENDIF
-      
+
       NUP=(NEL+M)/2
       NDW=(NEL-M)/2
 
@@ -1243,41 +1515,41 @@
 
       RETURN
       END SUBROUTINE POT_TYPE3
-      
+
 !**********************************************************************
 !
-! LDAUTYPE=5, Orbital polarization only 
+! LDAUTYPE=5, Orbital polarization only
 !
 !**********************************************************************
 
       SUBROUTINE POT_TYPE5(LMDIM,IATOM,ITYP,LNMAX,L_OF_LN,CDIJ,DBLE_LDAU)
 
       USE relativistic
-      
+
       IMPLICIT NONE
-      
+
       INTEGER LMDIM
       INTEGER IATOM
       INTEGER ITYP
       INTEGER LNMAX,LMMAX
       INTEGER L_OF_LN(LNMAX)
-      
+
       REAL(q) DBLE_LDAU
-      
+
       OVERLAP CRHODE(LMDIM,LMDIM,NCDIJ)
       OVERLAP CDIJ(LMDIM,LMDIM,NCDIJ)
-   
+
       INTEGER LN1,LN2,LMN1,LMN2
       INTEGER L,L1,L2,M1,M2
       INTEGER ISP,I
-      
+
       REAL(q) L_MOM(3),S_MOM(3),SNORM,L_PROJ
-      
+
       COMPLEX(q) , ALLOCATABLE :: L_OP(:,:,:),DUMMY(:,:,:)
       COMPLEX(q) , ALLOCATABLE :: L_OP_PROJ(:,:)
-            
+
       OVERLAP POT_U(LMDIM,LMDIM,NCDIJ)
-      
+
 ! Get me the L operator
       L=LANG_LDAPLUSU(ITYP)
       ALLOCATE(L_OP(2*L+1,2*L+1,3),DUMMY(2*L+1,2*L+1,4))
@@ -1294,7 +1566,7 @@
          ENDDO
          ENDDO
       ENDDO
-      ENDDO      
+      ENDDO
 ! Calculate spin moment
       S_MOM=0._q
       DO M1=1,2*L+1
@@ -1304,7 +1576,7 @@
       ENDDO
       SNORM=SQRT(S_MOM(1)*S_MOM(1)+S_MOM(2)*S_MOM(2)+S_MOM(3)*S_MOM(3))
 ! Calculate projection of orbital moment on local spin quantization axis
-      L_PROJ=(L_MOM(1)*S_MOM(1)+L_MOM(2)*S_MOM(2)+L_MOM(3)*S_MOM(3))/SNORM      
+      L_PROJ=(L_MOM(1)*S_MOM(1)+L_MOM(2)*S_MOM(2)+L_MOM(3)*S_MOM(3))/SNORM
 ! Construct L operator along spin direction
       ALLOCATE(L_OP_PROJ(2*L+1,2*L+1))
       L_OP_PROJ=(0._q,0._q)
@@ -1316,7 +1588,7 @@
       ENDDO
 ! Construct spin polarizing potential
       POT_U=0._q
-            
+
       LMN1=0
       DO LN1=1,LNMAX
       L1=L_OF_LN(LN1)
@@ -1330,38 +1602,38 @@
          DO M2=1,2*L2+1
             LMN2=LMN2+1
             IF (L2 /= LANG_LDAPLUSU(ITYP)) CYCLE
-           
+
             DO ISP=1,NCDIJ,NCDIJ-1
 
                POT_U(LMN1,LMN2,ISP)=U(ITYP)*L_PROJ*L_OP_PROJ(M2,M1)*OVERLAP_AE_(LN1,LN2,ITYP)
 
             ENDDO ! ISP
-                  
+
          ENDDO ! M2
          ENDDO ! LN2
       ENDDO ! M1
       ENDDO ! LN1
 
       CDIJ=CDIJ+POT_U
-      
+
       DBLE_LDAU=0._q
 
       DEALLOCATE(L_OP,DUMMY,L_OP_PROJ)
-      
+
       RETURN
       END SUBROUTINE POT_TYPE5
 
-      
+
       SUBROUTINE COULOMB_INTERACTION(ITYP)
-      
+
       USE prec
-      
+
       IMPLICIT NONE
-      
+
       INTEGER ITYP
       INTEGER L,M,M_
       INTEGER M1,M2,M3,M4,K,MA,MB,MC,MD
-      
+
       REAL(q) RAT42,RAT62
       COMPLEX(q) PREFAC
 
@@ -1370,8 +1642,8 @@
 
       L=LANG_LDAPLUSU(ITYP)
 
-      ALLOCATE(U_R2C(2*L+1,2*L+1))      
-      U_R2C=(0._q,0._q)          
+      ALLOCATE(U_R2C(2*L+1,2*L+1))
+      U_R2C=(0._q,0._q)
       DO M=1,2*L+1
          M_=M-L-1
          IF (M_>0) THEN
@@ -1386,16 +1658,16 @@
             U_R2C(-M_+L+1,M)=-CMPLX(0,(-1)**M_/SQRT(2._q),q)
          ENDIF
       ENDDO
-      
+
 !     u_r2c=(0._q,0._q)
 !     do m=1,2*L+1
 !        u_r2c(m,m)=1._q
 !     enddo
-            
+
       ALLOCATE(CGMAT(0:2*L,-L:L,-L:L))
       CGMAT=0._q
       CALL GAUNT_L(CGMAT,L)
-      
+
       ALLOCATE(F(0:2*L))
       F=0._q
       SELECT CASE(L)
@@ -1416,7 +1688,7 @@
          F(6)=RAT62*F(2)
       END SELECT
 
-      ALLOCATE(U_(0:2*L))      
+      ALLOCATE(U_(0:2*L))
       V=(0._q,0._q)
 
       DO M1=-L,L
@@ -1439,16 +1711,16 @@
          ENDDO !(MC)
          ENDDO !(MB)
          ENDDO !(MA)
-         
+
          V(M1+L+1,M3+L+1,M2+L+1,M4+L+1)=SUM(U_(0:2*L))
-     
+
       ENDDO !(M4)
       ENDDO !(M3)
       ENDDO !(M2)
       ENDDO !(M1)
-      
-      DEALLOCATE(U_R2C,CGMAT,F,U_)              
-      
+
+      DEALLOCATE(U_R2C,CGMAT,F,U_)
+
       END SUBROUTINE COULOMB_INTERACTION
 
 
@@ -1457,7 +1729,7 @@
       USE prec
       USE constant
       USE asa
-  
+
       IMPLICIT REAL(q) (A-H,O-Z)
       IMPLICIT INTEGER (I-N)
 
@@ -1477,7 +1749,7 @@
       DO I=1,IMAX
          FAC(I+1)= I*FAC(I)
       ENDDO
-  
+
 !---------------------------------------------------------------------
 ! loop over l    ,m     m =-l,+l
 ! loop over lp<=l,mp    mp=-lp,+lp
@@ -1501,7 +1773,7 @@
 
             T =CLEBGO(FAC(1),L1,L2,L3, M1, M2, M3)
             T0=CLEBG0(FAC(1),L1,L2,L3)
-           
+
             CGMAT(L3,-M2,M1)= T*T0* Q1 /(SRPI* SQRT( REAL(2*L3+1, KIND=q))) &
                          *SQRT( 4 *pi)/SQRT(2.*L3+1)*FS(M2)
             ! last line rescales to maintain compatibility
@@ -1534,7 +1806,7 @@
       INTEGER NIONS
       INTEGER I,ITYP(NIONS),ISP
       INTEGER LM1,LM2,LMSTART,LMSTOP
-      
+
       INTEGER L,M,INFO,J,K
       REAL(q), ALLOCATABLE :: W(:),RWORK(:)
       COMPLEX(q), ALLOCATABLE :: TMP(:,:),WORK(:)
@@ -1544,7 +1816,7 @@
 #else
       CALLMPI( M_sum_d( WDES%COMM, OCC_MAT_ALL, 2*LMMAX_*LMMAX_*NCDIJ*NIONS))
 #endif
-            
+
       IF (PRINTOCC /= 0 .AND. IU6>=0) THEN
          DO I=1,NIONS
             IF (LANG_LDAPLUSU(ITYP(I))<0) CYCLE
@@ -1562,14 +1834,14 @@
                DO LM1=LMSTART,LMSTOP
                SELECT CASE(LANG_LDAPLUSU(ITYP(I)))
                CASE(0)
-#ifdef realmode   
+#ifdef realmode
                   WRITE(IU6,'(F8.4)') (OCC_MAT_ALL(LM1,LM2,ISP,I), LM2=LMSTART,LMSTOP)
 #else
                   WRITE(IU6,'(F8.4,4X,F8.4)')  (REAL(OCC_MAT_ALL(LM1,LM2,ISP,I)), LM2=LMSTART,LMSTOP), &
                  &                              (AIMAG(OCC_MAT_ALL(LM1,LM2,ISP,I)), LM2=LMSTART,LMSTOP)
 #endif
                CASE(1)
-#ifdef realmode   
+#ifdef realmode
                   WRITE(IU6,'(3F8.4)') (OCC_MAT_ALL(LM1,LM2,ISP,I), LM2=LMSTART,LMSTOP)
 #else
                   WRITE(IU6,'(3F8.4,4X,3F8.4)')  (REAL(OCC_MAT_ALL(LM1,LM2,ISP,I)), LM2=LMSTART,LMSTOP), &
@@ -1581,24 +1853,24 @@
 #else
                   WRITE(IU6,'(5F8.4,4X,5F8.4)')  (REAL(OCC_MAT_ALL(LM1,LM2,ISP,I)), LM2=LMSTART,LMSTOP), &
                  &                                (AIMAG(OCC_MAT_ALL(LM1,LM2,ISP,I)), LM2=LMSTART,LMSTOP)
-#endif               
+#endif
                CASE(3)
-#ifdef realmode   
+#ifdef realmode
                   WRITE(IU6,'(7F8.4)') (OCC_MAT_ALL(LM1,LM2,ISP,I), LM2=LMSTART,LMSTOP)
 #else
                   WRITE(IU6,'(7F8.4,4X,7F8.4)')  (REAL(OCC_MAT_ALL(LM1,LM2,ISP,I)), LM2=LMSTART,LMSTOP), &
                  &                                (AIMAG(OCC_MAT_ALL(LM1,LM2,ISP,I)), LM2=LMSTART,LMSTOP)
-#endif               
+#endif
                END SELECT
                ENDDO
                WRITE(IU6,*)
             ENDDO
-            
+
             L=LANG_LDAPLUSU(ITYP(I))
             M=L*2+1
-            
+
             ALLOCATE(TMP(2*M,2*M),W(2*M),WORK(MAX(1,4*M-1)),RWORK(MAX(1,6*M-2)))
-            
+
             TMP(1:M,1:M)         = OCC_MAT_ALL(L*L+1:L*L+M,L*L+1:L*L+M,1,I)
             TMP(M+1:2*M,M+1:2*M) = OCC_MAT_ALL(L*L+1:L*L+M,L*L+1:L*L+M,NCDIJ,I)
             TMP(1:M,M+1:2*M)     = 0._q
@@ -1612,7 +1884,7 @@
             TMP=CONJG(TMP)
 
             CALL ZHEEV('V','L',2*M,TMP(1,1),2*M,W,WORK,MAX(1,4*M-1),RWORK,INFO)
-            
+
             WRITE(IU6,*) 'occupancies and eigenvectors'
             WRITE(IU6,*)
             DO LM1=1,2*M
@@ -1631,10 +1903,10 @@
                  &       W(LM1),(REAL(TMP(LM2,LM1)), LM2=1,2*M),(AIMAG(TMP(LM2,LM1)), LM2=1,2*M)
                END SELECT
             ENDDO
-            
+
             DEALLOCATE(TMP,W,WORK,RWORK)
-            
-         ENDDO      
+
+         ENDDO
       ENDIF
 
       OCC_MAT_ALL=0._q
@@ -1645,7 +1917,7 @@
       RETURN
       END SUBROUTINE LDAPLUSU_PRINTOCC
 
-      
+
 
 
 !***********************************************************************
@@ -1653,29 +1925,29 @@
 !***********************************************************************
 
       SUBROUTINE CALC_ORBITAL_MOMENT(LMDIM,IATOM,ITYP,CRHODE,PP,THETA,PHI)
-      
+
       USE pseudo
       USE relativistic
-      
+
       IMPLICIT NONE
-      
+
       TYPE(potcar) PP
-      
+
       INTEGER LMDIM,IATOM
-      
+
       INTEGER LNMAX,LMAX,LMMAX
       INTEGER L,L1,M1,L2,M2,LM1,LM2,LMN1,LMN2,LN1,LN2
       INTEGER I,ISP,ITYP
-      
+
       REAL(q) THETA,PHI
-      
+
       COMPLEX(q), ALLOCATABLE :: L_OP(:,:,:,:)
       COMPLEX(q), ALLOCATABLE :: DUMMY(:,:,:,:)
 
       OVERLAP CRHODE(LMDIM,LMDIM,NCDIJ) ! occupancy matrix
 
 ! quick return
-      IF (LMAX_==0) RETURN 
+      IF (LMAX_==0) RETURN
 
 ! Calculate the occupation matrix
       OCC_MAT=0._q
@@ -1704,12 +1976,12 @@
          ENDDO !(LN2)
       ENDDO !(M1)
       ENDDO !(LN1)
-      
+
 ! Get me the L operator
       ALLOCATE(L_OP(2*LMAX+1,2*LMAX+1,3,0:LMAX),DUMMY(2*LMAX+1,2*LMAX+1,4,0:LMAX))
-           
-      L_OP=(0._q,0._q)      
-      
+
+      L_OP=(0._q,0._q)
+
       DO L=1,LMAX
          CALL SETUP_LS(L,THETA,PHI,L_OP(1:2*L+1,1:2*L+1,1:3,L),DUMMY(1:2*L+1,1:2*L+1,1:4,L))
       ENDDO
@@ -1730,38 +2002,38 @@
       ENDDO
       ENDDO
 #endif
-      
+
       DEALLOCATE(L_OP,DUMMY)
-      
+
       RETURN
       END SUBROUTINE CALC_ORBITAL_MOMENT
 
-      
+
 !***********************************************************************
 !
 !***********************************************************************
-      
+
       SUBROUTINE WRITE_ORBITAL_MOMENT(WDES,NIONS,IU6)
-      
+
       USE wave
       USE main_mpi
       USE mpimy
-      
+
       IMPLICIT NONE
 
       TYPE(wavedes) WDES
-      
+
       INTEGER IU6
       INTEGER NIONS
       INTEGER I,N,L
 
 ! quick return
-      IF (LMAX_==0) RETURN 
+      IF (LMAX_==0) RETURN
 
       CALLMPI( M_sum_d( WDES%COMM, ORBMOM, LMAX_*NIONS*3))
 
       IF (IU6>=0) THEN
-      
+
       DO I=1,3
       WRITE(IU6,*)
       SELECT CASE (I)
@@ -1779,7 +2051,7 @@
          WRITE(IU6,*) '# of ion     p       tot'
          WRITE(IU6,*) '--------------------------------'
          DO N=1,NIONS
-            WRITE(IU6,'(I3,6X,2(F8.3))') N,ORBMOM(1:LMAX_,I,N),SUM(ORBMOM(1:LMAX_,I,N))         
+            WRITE(IU6,'(I3,6X,2(F8.3))') N,ORBMOM(1:LMAX_,I,N),SUM(ORBMOM(1:LMAX_,I,N))
          ENDDO
          WRITE(IU6,*) '--------------------------------'
          WRITE(IU6,'(9X,2(F8.3))') (SUM(ORBMOM(L,I,1:NIONS)), L=1,LMAX_),SUM(ORBMOM(1:LMAX_,I,1:NIONS))
@@ -1787,7 +2059,7 @@
          WRITE(IU6,*) '# of ion     p       d       tot'
          WRITE(IU6,*) '----------------------------------------'
          DO N=1,NIONS
-            WRITE(IU6,'(I3,6X,3(F8.3))') N,ORBMOM(1:LMAX_,I,N),SUM(ORBMOM(1:LMAX_,I,N))         
+            WRITE(IU6,'(I3,6X,3(F8.3))') N,ORBMOM(1:LMAX_,I,N),SUM(ORBMOM(1:LMAX_,I,N))
          ENDDO
          WRITE(IU6,*) '----------------------------------------'
          WRITE(IU6,'(9X,3(F8.3))') (SUM(ORBMOM(L,I,1:NIONS)), L=1,LMAX_),SUM(ORBMOM(1:LMAX_,I,1:NIONS))
@@ -1795,7 +2067,7 @@
          WRITE(IU6,*) '# of ion     p       d       f       tot'
          WRITE(IU6,*) '------------------------------------------------'
          DO N=1,NIONS
-            WRITE(IU6,'(I3,6X,4(F8.3))') N,ORBMOM(1:LMAX_,I,N),SUM(ORBMOM(1:LMAX_,I,N))         
+            WRITE(IU6,'(I3,6X,4(F8.3))') N,ORBMOM(1:LMAX_,I,N),SUM(ORBMOM(1:LMAX_,I,N))
          ENDDO
          WRITE(IU6,*) '------------------------------------------------'
          WRITE(IU6,'(9X,4(F8.3))') (SUM(ORBMOM(L,I,1:NIONS)), L=1,LMAX_),SUM(ORBMOM(1:LMAX_,I,1:NIONS))
@@ -1803,12 +2075,12 @@
 
       ENDDO
       ENDIF
-      
+
       ORBMOM=0._q
-      
+
       RETURN
       END SUBROUTINE WRITE_ORBITAL_MOMENT
-      
+
       END MODULE LDAPLUSU_MODULE
 
 !**********************************************************************
@@ -1825,4 +2097,3 @@
       L_NO_LSDA_GLOBAL=L_NO_LSDA()
 
       END FUNCTION L_NO_LSDA_GLOBAL
-
diff -ruN ./src/main.F ../../vasp.5.4.4/src/main.F
--- ./src/main.F	2017-04-20 17:03:58.000000000 +0800
+++ ../../vasp.5.4.4/src/main.F	2019-04-16 21:00:00.132503921 +0800
@@ -42,8 +42,8 @@
 ! For the mixing a Broyden/Pulay like method is used (see for instance):
 !  D. Johnson, Phys. Rev. B 38, 12807 (1988)
 !
-! The program can use normconserving PP, 
-! generalised ultrasoft-PP (Vanderbilt-PP Vanderbilt Phys Rev B 40,  
+! The program can use normconserving PP,
+! generalised ultrasoft-PP (Vanderbilt-PP Vanderbilt Phys Rev B 40,
 ! 12255 (1989)) and PAW (P.E. Bloechl, Phys. Rev. B{\bf 50}, 17953 (1994))
 ! datasets. Partial core corrections can be handled
 ! Spin and GGA and exact exchange functionals are implemented
@@ -152,9 +152,9 @@
       USE dvvtrajectory
 
       USE mlwf
-#ifdef VASP2WANNIER90 
+#ifdef VASP2WANNIER90
       USE dmft
-      USE crpa 
+      USE crpa
 #endif
       USE chgfit
       USE stockholder
@@ -242,7 +242,7 @@
        INTEGER :: SEED(3),SEED_INIT(3)
        INTEGER :: DTVALUES(8)
        INTEGER :: IDUMLONG
-       INTEGER :: CLOCK       
+       INTEGER :: CLOCK
        INTEGER, PARAMETER :: SEED1_MAX=900000000, K_SEED=3
        INTEGER, PARAMETER :: SEED2_MAX=1000000
 #endif
@@ -292,7 +292,7 @@
       GDEF   ,POINTER::   CHF(:,:,:,:),CHAM(:,:,:,:)
 !  optics stuff
       GDEF   ,ALLOCATABLE::   NABIJ(:,:)
-!  
+!
       LOGICAL :: LVCADER
 
 !-----remaining mainly work arrays
@@ -331,7 +331,7 @@
       INTEGER NORDER   !   order of smearing
 !---- a few logical and string variables
       LOGICAL    LTMP,LSTOP2
-      LOGICAL    LPAW           ! paw is used 
+      LOGICAL    LPAW           ! paw is used
       LOGICAL    LPARD          ! partial band decomposed charge density
       LOGICAL    LREALLOCATE    ! reallocation of proj operators required
       LOGICAL    L_NO_US        ! no ultrasoft PP
@@ -412,7 +412,7 @@
       g_io%PENALTY=534
 #endif
 !
-! with all the dynamic libraries (blas, lapack, scalapack etc. 
+! with all the dynamic libraries (blas, lapack, scalapack etc.
 ! VASP has a size of at least 30 Mbyte
 !
       CALL INIT_FINAL_TIMING
@@ -520,7 +520,7 @@
       CALL RD_POSCAR_HEAD(LATT_CUR, T_INFO, &
      &           NIOND,NIONPD, NTYPD,NTYPPD, IO%IU0, IO%IU6)
 
-      ALLOCATE(T_INFO%ATOMOM(3*NIOND),T_INFO%RWIGS(NTYPPD),T_INFO%ROPT(NTYPD),T_INFO%POMASS(NTYPD), & 
+      ALLOCATE(T_INFO%ATOMOM(3*NIOND),T_INFO%RWIGS(NTYPPD),T_INFO%ROPT(NTYPD),T_INFO%POMASS(NTYPD), &
                T_INFO%DARWIN_V(NTYPD), T_INFO%DARWIN_R(NTYPD),T_INFO%VCA(NTYPD))
 
       IF (IO%IU6>=0) THEN
@@ -557,10 +557,10 @@
           DYN%IBRION,INFO%ICHARG,INFO%INIWAV,INFO%NELM,INFO%NELMALL,INFO%NELMIN,INFO%NELMDL,INFO%EDIFF,DYN%EDIFFG, &
           DYN%NSW,DYN%ISIF,PRED%IWAVPR,SYMM%ISYM,DYN%NBLOCK,DYN%KBLOCK,INFO%ENMAX,DYN%POTIM,DYN%TEBEG, &
           DYN%TEEND,DYN%NFREE, &
-          PACO%NPACO,PACO%APACO,T_INFO%NTYP,NTYPD,DYN%SMASS,SCALEE,T_INFO%POMASS, & 
+          PACO%NPACO,PACO%APACO,T_INFO%NTYP,NTYPD,DYN%SMASS,SCALEE,T_INFO%POMASS, &
           T_INFO%DARWIN_V,T_INFO%DARWIN_R,T_INFO%VCA,LVCADER, &
-          T_INFO%RWIGS,INFO%NELECT,INFO%NUP_DOWN,INFO%TIME, & 
-          KPOINTS%EMIN,KPOINTS%EMAX,KPOINTS%EFERMI,KPOINTS%ISMEAR,KPOINTS%SPACING,KPOINTS%LGAMMA, & 
+          T_INFO%RWIGS,INFO%NELECT,INFO%NUP_DOWN,INFO%TIME, &
+          KPOINTS%EMIN,KPOINTS%EMAX,KPOINTS%EFERMI,KPOINTS%ISMEAR,KPOINTS%SPACING,KPOINTS%LGAMMA, &
           DYN%PSTRESS,INFO%NDAV, &
           KPOINTS%SIGMA,KPOINTS%LTET,INFO%WEIMIN,INFO%EBREAK,INFO%DEPER,IO%NWRITE,INFO%LCORR, &
           IO%IDIOT,T_INFO%NIONS,T_INFO%NTYPP,IO%LMUSIC,IO%LOPTICS,STM, &
@@ -623,7 +623,7 @@
       ENDIF
 ! METAGGA not implemented for non collinear magnetism
 !      IF (WDES%LNONCOLLINEAR .AND. INFO%LMETAGGA) THEN
-!         WRITE(*,*) 'METAGGA for non collinear magnetism not supported.' 
+!         WRITE(*,*) 'METAGGA for non collinear magnetism not supported.'
 !         WRITE(*,*) 'exiting VASP; sorry for the inconveniences.'
 !         STOP
 !      ENDIF
@@ -690,7 +690,7 @@
       CALL CRPA_READER(IO%IU5, IO%IU6, IO%IU0, NBANDS, L2E4W, L2E4W_ALL ,IO%LDOWNSAMPLE)
       CALL PEAD_READER(IO%IU5, IO%IU6, IO%IU0)
       CALL DMATRIX_READER(IO%IU5, IO%IU6, IO%IU0)
-      CALL XC_FOCK_READER(IO%IU5, IO%IU0, IO%IU6, INFO%SZPREC, DYN%ISIF, SYMM%ISYM, INFO%IALGO, & 
+      CALL XC_FOCK_READER(IO%IU5, IO%IU0, IO%IU6, INFO%SZPREC, DYN%ISIF, SYMM%ISYM, INFO%IALGO, &
          LATT_CUR%OMEGA, T_INFO%NTYP, T_INFO%NIONS, MIX%IMIX, MIX%AMIX, MIX%AMIX_MAG, MIX%BMIX, MIX%BMIX_MAG, IO%LVTOT)
       CALL EGRAD_READER(IO%IU5, IO%IU6, IO%IU0, T_INFO%NTYP)
       CALL CLASSICFIELDS_READER(IO%IU5, IO%IU6, IO%IU0)
@@ -756,7 +756,7 @@
       ENDIF
 
       IF (USELDApU().OR.LCALC_ORBITAL_MOMENT()) &
-     &   CALL INITIALIZE_LDAU(T_INFO%NIONS,T_INFO%NTYP,P,WDES%LNONCOLLINEAR,IO%IU0,IO%IDIOT)
+     &   CALL INITIALIZE_LDAU(T_INFO%NIONS,T_INFO%NTYP,P,WDES%LNONCOLLINEAR,IO%IU5,IO%IU6,IO%IU0,IO%IDIOT)
 
       CALL SET_PAW_AUG(T_INFO%NTYP, P, IO%IU6, LMAX_CALC, LCOMPAT)
 !-----------------------------------------------------------------------
@@ -818,7 +818,7 @@
       CALL chain_init( T_INFO, IO)
 !-----------------------------------------------------------------------
 !xml finish copying parameters from INCAR to xml file
-! no INCAR reading from here 
+! no INCAR reading from here
       CALL XML_CLOSE_TAG("incar")
 !-----------------------------------------------------------------------
 #if CUDA_GPU
@@ -851,7 +851,7 @@
 
 
 #ifdef tbdyn
-      !c some MD methods (e.q. Langevin dynamics) do not conserve total momentum! 
+      !c some MD methods (e.q. Langevin dynamics) do not conserve total momentum!
       IF ( T_INFO%LSDYN ) THEN
          CALL SET_SELECTED_VEL_ZERO(T_INFO, DYN%VEL,LATT_CUR)
       ELSE IF (MDALGO/=3 .AND. MDALGO/=31 .AND. DYN%IBRION/=44 .AND. DYN%IBRION/=40) THEN
@@ -915,12 +915,12 @@
 !  number of k-points and k-points in reciprocal lattice
 !=======================================================================
       IF(IO%IU6>=0)  WRITE(TIU6,*)
-      ! use full k-point grid if finite differences are used or 
+      ! use full k-point grid if finite differences are used or
       ! linear response is applied
-      IF (DYN%IBRION==5 .OR. DYN%IBRION==6 .OR. DYN%IBRION==7.OR. DYN%IBRION==8 & 
-          .OR. LEPSILON .OR. LVEL .OR. KINTER/=0 .OR. LMAGBLOCH  & 
+      IF (DYN%IBRION==5 .OR. DYN%IBRION==6 .OR. DYN%IBRION==7.OR. DYN%IBRION==8 &
+          .OR. LEPSILON .OR. LVEL .OR. KINTER/=0 .OR. LMAGBLOCH  &
           .OR. LCHIMAG .OR. LTIME_EVOLUTION) CALL USE_FULL_KPOINTS
-      ! apply preferentially time inversion symmetry to generate orbitals at -k    
+      ! apply preferentially time inversion symmetry to generate orbitals at -k
       IF (WDES%LORBITALREAL) CALL USE_TIME_INVERSION
 
       IF (LBERRY) THEN
@@ -940,7 +940,7 @@
             .NOT.WDES%LSPIRAL, &
             SYMM%ISYM<0,IO%IU6,IO%IU0)
 
-         CALL SETUP_FULL_KPOINTS(KPOINTS,LATT_CUR,T_INFO%NIOND, & 
+         CALL SETUP_FULL_KPOINTS(KPOINTS,LATT_CUR,T_INFO%NIOND, &
             SYMM%ROTMAP,SYMM%MAGROT,SYMM%ISYM, &
             SYMM%ISYM>=0.AND. &
             .NOT.WDES%LSORBIT.AND. &
@@ -951,7 +951,7 @@
             SYMM%ISYM>=0.AND..NOT.WDES%LNONCOLLINEAR, &
             SYMM%ISYM<0,IO%IU6,IO%IU0)
 
-         CALL SETUP_FULL_KPOINTS(KPOINTS,LATT_CUR,T_INFO%NIOND, & 
+         CALL SETUP_FULL_KPOINTS(KPOINTS,LATT_CUR,T_INFO%NIOND, &
             SYMM%ROTMAP,SYMM%MAGROT,SYMM%ISYM, &
             SYMM%ISYM>=0.AND..NOT.WDES%LNONCOLLINEAR, &
             IO%IU6,IO%IU0, LSYMGRAD)
@@ -1054,7 +1054,7 @@
      &        ITUT,2,CDUM,1,LDUM,1,IO%IU0,IO%IDIOT)
          CALL VTUTOR('W','NBANDS changed',RTUT,1, &
      &        ITUT,2,CDUM,1,LDUM,1,IO%IU6,IO%IDIOT)
-         
+
       ENDIF
 
       NBANDS=((NBANDS+NPAR-1)/NPAR)*NPAR
@@ -1151,7 +1151,7 @@
          WDES%NRSPINORS = 2
          INFO%RSPIN = 1
       ELSE
-         WDES%NRSPINORS = 1 
+         WDES%NRSPINORS = 1
       ENDIF
       WDES%RSPIN = INFO%RSPIN
 
@@ -1217,7 +1217,7 @@
       ITUT(2)=YCUTOF*WFACT+0.5_q
       ITUT(3)=ZCUTOF*WFACT+0.5_q
       CALL FFTCHK(ITUT(1:3))
-      IF (IO%IU6>=0 .AND. (ITUT(1)/=NGX .OR. ITUT(2)/=NGY .OR. ITUT(3)/=NGZ)) & 
+      IF (IO%IU6>=0 .AND. (ITUT(1)/=NGX .OR. ITUT(2)/=NGY .OR. ITUT(3)/=NGZ)) &
         WRITE(TIU6,72111) ITUT(1),ITUT(2),ITUT(3)
 
 72111 FORMAT(' Based on PREC, I would recommend the following setting:'/ &
@@ -1473,7 +1473,7 @@
           DYN%NSW,DYN%ISIF,PRED%IWAVPR,SYMM%ISYM,DYN%NBLOCK,DYN%KBLOCK,INFO%ENMAX,DYN%POTIM,DYN%TEBEG, &
           DYN%TEEND,DYN%NFREE, &
           PACO%NPACO,PACO%APACO,T_INFO%NTYP,NTYPD,DYN%SMASS,SCALEE,T_INFO%POMASS,T_INFO%DARWIN_V,T_INFO%DARWIN_R,  &
-          T_INFO%RWIGS,INFO%NELECT,INFO%NUP_DOWN,INFO%TIME,KPOINTS%EMIN,KPOINTS%EMAX,KPOINTS%EFERMI, & 
+          T_INFO%RWIGS,INFO%NELECT,INFO%NUP_DOWN,INFO%TIME,KPOINTS%EMIN,KPOINTS%EMAX,KPOINTS%EFERMI, &
           KPOINTS%ISMEAR,KPOINTS%SPACING,KPOINTS%LGAMMA,DYN%PSTRESS,INFO%NDAV, &
           KPOINTS%SIGMA,KPOINTS%LTET,INFO%WEIMIN,INFO%EBREAK,INFO%DEPER,IO%NWRITE,INFO%LCORR, &
           IO%IDIOT,T_INFO%NIONS,T_INFO%NTYPP,IO%LMUSIC,IO%LOPTICS,STM, &
@@ -1555,7 +1555,7 @@
            WRITE(TIU6,*)'relaxation of ions and charge simultaneously'
       ELSE IF (DYN%IBRION==11) THEN
            WRITE(TIU6,*)'interactive mode, write forces and read positions'
-      !tb beg 
+      !tb beg
       ELSE IF (DYN%IBRION==44) THEN
           WRITE(TIU6,*)'improved dimer method for transition state relaxation'
       !tb end
@@ -1673,7 +1673,7 @@
 !  RMM-DIIS + Davidson
       ELSE IF (INFO%IALGO>=60) THEN
         IF(IO%IU6>=0)  WRITE(TIU6,*) 'RMM-DIIS sequential band-by-band and'
-        IF(IO%IU6>=0)  WRITE(TIU6,*) ' variant of blocked Davidson during initial phase' 
+        IF(IO%IU6>=0)  WRITE(TIU6,*) ' variant of blocked Davidson during initial phase'
         INFO%IALGO=INFO%IALGO-60
         INFO%LRMM   =.TRUE.
         INFO%LDAVID =.TRUE.
@@ -2048,7 +2048,7 @@
 ! allocate real space projectors
       CALL NONLR_ALLOC(NONLR_S)
 !  init FFT
-      CALL FFTINI(WDES%NINDPW(1,1),WDES%NGVECTOR(1),KPOINTS%NKPTS,WDES%NGDIM,GRID) 
+      CALL FFTINI(WDES%NINDPW(1,1),WDES%NGVECTOR(1),KPOINTS%NKPTS,WDES%NGDIM,GRID)
 #ifdef MPI
       CALL MAPSET(GRID)   ! generate the communication maps (patterns) for FFT
       IF (IO%IU6 >=0) THEN
@@ -2081,12 +2081,12 @@
       LMDIM   =P(1)%LMDIM
 
 #if defined(CUDA_GPU) && defined(USE_PINNED_MEMORY)
-      CALL nvpinnedmalloc(SV_PTR,DIMREAL(GRID%MPLWV)*NCDIJ*int(c_sizeof(fake),c_size_t)) 
+      CALL nvpinnedmalloc(SV_PTR,DIMREAL(GRID%MPLWV)*NCDIJ*int(c_sizeof(fake),c_size_t))
       CALL c_f_pointer(SV_PTR,SV,(/DIMREAL(GRID%MPLWV),NCDIJ/))
 ! charges, potentials and so on
       CALL nvpinnedmalloc(CHTOT_PTR, GRIDC%MPLWV * NCDIJ*int(c_sizeof(fakec),c_size_t))
       CALL c_f_pointer(CHTOT_PTR, CHTOT, (/GRIDC%MPLWV,NCDIJ/))
-#else   
+#else
       ALLOCATE(CHTOT(GRIDC%MPLWV,NCDIJ),SV(DIMREAL(GRID%MPLWV),NCDIJ))
 #endif
       ALLOCATE(CHTOTL(GRIDC%MPLWV,NCDIJ),DENCOR(GRIDC%RL%NP), &
@@ -2114,14 +2114,14 @@
       ENDIF
 
       CALL ALLOCATE_AVEC(HAMILTONIAN%AVEC, HAMILTONIAN%AVTOT, GRID, GRIDC)
-      
+
       CALL ALLOCATE_MU(HAMILTONIAN%MU, HAMILTONIAN%MUTOT, GRID, GRIDC, WDES)
 ! test_
 !     CALL GENERATE_TAU_HANDLE(KINEDEN, GRIDC, WDES%NCDIJ)
       CALL ALLOCATE_TAU(KINEDEN%TAU,KINEDEN%TAUC,KINEDEN%TAUL,GRIDC,WDES%NCDIJ)
 ! test_
       CALL CREATE_CMBJ_AUX(GRIDC,T_INFO,LATT_CUR)
-      
+
       DWRITE0 'allocation done'
 !
       ALLOCATE(CWORK1(GRID%MPLWV))
@@ -2199,7 +2199,7 @@
 
       IF (INFO%ISTART/=2) LATT_INI=LATT_CUR
 !=======================================================================
-! At this very point everything has been read in 
+! At this very point everything has been read in
 ! and we are ready to write all important information
 ! to the xml file
 !=======================================================================
@@ -2254,7 +2254,7 @@
          ! and reset INICHG to 1 so that CHGCAR is read as well
          INFO%INICHG=1
       ENDIF
- 
+
       ! then initialize CRHODE and than RHOLM (PAW related occupancies)
       CALL DEPATO(WDES, LMDIM, CRHODE, INFO%LOVERL, P, T_INFO)
       CALL SET_RHO_PAW(WDES, P, T_INFO, INFO%LOVERL, WDES%NCDIJ, LMDIM, &
@@ -2357,7 +2357,7 @@
         IF (INFO%INICHG==0)  INFO%INICHG=2
         ! no magnetization density set it according to MAGMOM
         IF (INFO%INICHG==-1) THEN
-           IF (WDES%NCDIJ>1) & 
+           IF (WDES%NCDIJ>1) &
                 CALL MRHOATO(.FALSE.,GRIDC,T_INFO,LATT_CUR%B,P,CHTOT(1,2),WDES%NCDIJ-1)
            INFO%INICHG=1
            IF( TIU0 >=0) WRITE(TIU0,*)'magnetization density of overlapping atoms calculated'
@@ -2372,7 +2372,7 @@
          ELSE
             CALL RHOATO_PARTICLE_MESH(.FALSE.,.FALSE.,GRIDC,LATT_CUR,T_INFO,INFO,P,CHTOT,IO%IU6)
          ENDIF
-         IF (WDES%NCDIJ>1) & 
+         IF (WDES%NCDIJ>1) &
               CALL MRHOATO(.FALSE.,GRIDC,T_INFO,LATT_CUR%B,P,CHTOT(1,2),WDES%NCDIJ-1)
 
          IF (IO%IU6>=0) WRITE(TIU6,*)'charge density of overlapping atoms calculated'
@@ -2412,8 +2412,8 @@
         WRITE(TIU6,130)
       ENDIF
 
-      ! add Gaussian "charge-transfer" charges, if required 
-      CALL RHOADD_GAUSSIANS(T_INFO,LATT_CUR,P,GRIDC,NCDIJ,CHTOT,CSTRF) 
+      ! add Gaussian "charge-transfer" charges, if required
+      CALL RHOADD_GAUSSIANS(T_INFO,LATT_CUR,P,GRIDC,NCDIJ,CHTOT,CSTRF)
       CALL RHOADD_GAUSSIANS_LIST(LATT_CUR,GRIDC,NCDIJ,CHTOT)
 
       DWRITE0 'atomic charge done'
@@ -2511,7 +2511,7 @@
 !         CALL XML_INCAR_V('FERDO','F',IDUM,W%FERTOT(1,1,INFO%ISPIN),CDUM,LDUM,CHARAC,N)
       ENDIF
       CLOSE(IO%IU5)
- 
+
 ! if ISMEAR == -2 occupancies will be kept fixed
       IF (KPOINTS%ISMEAR==-2) THEN
          KPOINTS%SIGMA=-ABS(KPOINTS%SIGMA)
@@ -2556,7 +2556,7 @@
 
       CALL CALC_JPAW_HAMIL(T_INFO, P)
       ! set vector potential
-      CALL VECTORPOT(GRID, GRIDC, GRID_SOFT, SOFT_TO_C,  WDES%COMM_INTER, & 
+      CALL VECTORPOT(GRID, GRIDC, GRID_SOFT, SOFT_TO_C,  WDES%COMM_INTER, &
                  LATT_CUR, T_INFO%POSION, HAMILTONIAN%AVEC, HAMILTONIAN%AVTOT)
       ! first call to SETDIJ_AVEC only sets phase twisted projectors
       CALL SETDIJ_AVEC(WDES,GRIDC,GRIDUS,C_TO_US,LATT_CUR,P,T_INFO,INFO%LOVERL, &
@@ -2571,7 +2571,7 @@
 
       CALL PROALL (GRID,LATT_CUR,NONLR_S,NONL_S,W)
       DWRITE0 'proall done'
- 
+
       CALL ORTHCH(WDES,W, INFO%LOVERL, LMDIM,CQIJ)
       CALL REDIS_PW_OVER_BANDS(WDES, W)
       DWRITE0 'orthch done'
@@ -2600,7 +2600,7 @@
       IF (INFO%INICHG==0 .OR. INFO%INICHG==4 .OR. (.NOT.INFO%LCHCOS .AND. INFO%NELMDL==0)  ) THEN
          IF (IO%IU6>=0) &
               WRITE(TIU6,*)'initial charge from wavefunction'
-         
+
          IF (IO%IU0>=0) &
               WRITE(TIU0,*)'initial charge from wavefunction'
 
@@ -2610,7 +2610,7 @@
               CHDEN, LMDIM, CRHODE, CHTOT, RHOLM, N_MIX_PAW, IRDMAX)
 
          CALL SET_KINEDEN(GRID,GRID_SOFT,GRIDC,SOFT_TO_C,LATT_CUR,SYMM, &
-              T_INFO%NIONS,W,WDES,KINEDEN)      
+              T_INFO%NIONS,W,WDES,KINEDEN)
       ENDIF
 
 !=======================================================================
@@ -2721,7 +2721,7 @@
          ! optical properties do not work for conventional GW
          ! because the potential is non-local
          ! OEP are fine however
-            IO%LOPTICS=.FALSE. 
+            IO%LOPTICS=.FALSE.
          ENDIF
          IF (.NOT. LRPAFORCE) THEN
             CALL DO_RPA
@@ -2831,7 +2831,7 @@
             CALL DEALLOCW(W_G)
             DEALLOCATE(CHAM, CHF)
             ALLOCATE(CHAM(1,1,1,1),CHF (1,1,1,1))
-         ENDIF        
+         ENDIF
       ENDIF
 
 #ifdef VASP2WANNIER90
@@ -2847,7 +2847,7 @@
                  T_INFO%NIONS,SYMM%ROTMAP,SYMM%MAGROT,SYMM%ISYM,IO%IU6,IO%IU0)
             CALL KPAR_SYNC_ALL(WDES,W)
             CALL RE_GEN_LAYOUT( GRID, WDES, KPOINTS, LATT_CUR, LATT_CUR,-1, IO%IU0)
-            CALL PEAD_RESETUP_WDES(WDES, GRID, KPOINTS, LATT_CUR, LATT_CUR, IO) 
+            CALL PEAD_RESETUP_WDES(WDES, GRID, KPOINTS, LATT_CUR, LATT_CUR, IO)
             CALL REALLOCATE_WAVE( W, GRID, WDES, NONL_S, T_INFO, P, LATT_CUR)
          ENDIF
          CALL MLWF_WANNIER90(WDES,W,P,CQIJ,T_INFO,LATT_CUR,INFO,IO)
@@ -2971,7 +2971,7 @@
       ! no forces if potential was read in INFO%INICHG==4
       ! no forces if inner eigenvalue solver are used
       ! no forces for RPA (has already been done)
-      IF ( EXXOEP==0 .AND.  (INFO%LONESW .OR. INFO%LDIAG .OR. INFO%IALGO>4) & 
+      IF ( EXXOEP==0 .AND.  (INFO%LONESW .OR. INFO%LDIAG .OR. INFO%IALGO>4) &
            .AND. INFO%INICHG/=4 .AND. INFO%IHARMONIC==0 .AND. (.NOT. LCHI)) THEN
         CALL FORCE_AND_STRESS( &
           KINEDEN,HAMILTONIAN,P,WDES,NONLR_S,NONL_S,W,LATT_CUR, &
@@ -2992,7 +2992,7 @@
 
       IF (IO%IU6>=0) THEN
          WRITE(TIU6,130)
-         WRITE(TIU6,7261) '  FREE ENERGIE OF THE ION-ELECTRON SYSTEM (eV)', & 
+         WRITE(TIU6,7261) '  FREE ENERGIE OF THE ION-ELECTRON SYSTEM (eV)', &
             TOTEN,TOTEN-E%EENTROPY,TOTEN-E%EENTROPY/(2+NORDER)
       ENDIF
 
@@ -3018,7 +3018,7 @@
 
 
 ! check the consistency of forces and total energy
-      CALL CHECK(T_INFO%NIONS,DYN%POSION,TIFOR,EWIFOR,TOTEN,E%TEWEN,LATT_CUR%A,IO%IU6) 
+      CALL CHECK(T_INFO%NIONS,DYN%POSION,TIFOR,EWIFOR,TOTEN,E%TEWEN,LATT_CUR%A,IO%IU6)
       IF (IO%IU6>=0) WRITE(IO%IU6,130)
 
 !-----------------------------------------------------------------------
@@ -3027,7 +3027,7 @@
 !-----------------------------------------------------------------------
       IF (LVCADER) THEN
          ! derivative with respect to VCA parameters
-         CALL VCA_DER( & 
+         CALL VCA_DER( &
               HAMILTONIAN,KINEDEN, &
               P,WDES,NONLR_S,NONL_S,W,LATT_CUR, &
               T_INFO,INFO,IO,KPOINTS,GRID,GRID_SOFT, &
@@ -3083,7 +3083,7 @@
 !=======================================================================
 !
 !  electronic polarisation
-! 
+!
 !=======================================================================
       IF (LBERRY) THEN
       io_begin
@@ -3132,14 +3132,14 @@
       ! scale forces and total energy by scaling argument
       ! this allows  integration from ideal gas to liquid state
       ! alternatively if the DYNMATFULL file exists add forces from
-      ! second order Hessian matrix (allows thermodynamic integration from 
+      ! second order Hessian matrix (allows thermodynamic integration from
       ! harmonic model)
       ! maybe this should go over to the force.F file
       ! of course it is unique since it  changes radically energy
       CALL DYNMATFULL_ENERGY_FORCE(SCALEE, T_INFO%NIONS, DYN%POSION, TOTEN, TIFOR, LATT_CUR%A , IO%IU0)
       IF (SCALEE/=1) THEN
          EENTROPY=E%EENTROPY*SCALEE
-         IF (IO%IU6>=0) WRITE(TIU6,7261) '  SCALED FREE ENERGIE OF THE ION-ELECTRON SYSTEM (eV)', & 
+         IF (IO%IU6>=0) WRITE(TIU6,7261) '  SCALED FREE ENERGIE OF THE ION-ELECTRON SYSTEM (eV)', &
             TOTEN,TOTEN-EENTROPY,TOTEN-EENTROPY/(2+NORDER)
       ENDIF
 
@@ -3151,7 +3151,7 @@
 
       IF (DYN%IBRION /=5 .AND. DYN%IBRION /=6 .AND. DYN%IBRION /=7 ) &
       CALL SET_SELECTED_FORCES_ZERO(T_INFO,DYN%VEL,TIFOR,LATT_CUR)
-  
+
       EKIN=0
       EKIN_LAT=0
       TEIN=0
@@ -3181,7 +3181,7 @@
 !
 ! write statement for static calculations with possibly extensive
 ! post processing (GW, dielectric response, ...)
-! 
+!
 !=======================================================================
       IF (DYN%IBRION/=0) THEN
          CALL XML_TAG("energy")
@@ -3331,7 +3331,7 @@
              TOTEN-E%EENTROPY/(2+NORDER),EKIN,ES,EPS
         IF (IO%IU0>=0) &
              WRITE(TIU0,7280,ADVANCE='NO')NSTEP,TEIN,ETOTAL,TOTEN, &
-             TOTEN-E%EENTROPY/(2+NORDER),EKIN,ES,EPS         
+             TOTEN-E%EENTROPY/(2+NORDER),EKIN,ES,EPS
         IF (WDES%NCDIJ>=2) THEN
            WRITE(17,77280) RHOTOT(2:WDES%NCDIJ)
            IF (IO%IU0>=0) WRITE(TIU0,77280) RHOTOT(2:WDES%NCDIJ)
@@ -3342,7 +3342,7 @@
 
     IF (.NOT. LJ_ONLY) THEN
         WRITE(TIU6,7270) DISMAX
-    END IF        
+    END IF
         io_end
 
 7260  FORMAT(/ &
@@ -3487,7 +3487,7 @@
        IF (.NOT. LJ_ONLY) THEN
 ! sum energy of images along chain
         EENTROPY=E%EENTROPY*SCALEE
-        
+
         IF (IMAGES==0) THEN
            CALLMPI_C( sum_chain( TOTEN ))
            CALLMPI_C( sum_chain( EENTROPY ))
@@ -3501,7 +3501,7 @@
              TOTEN-EENTROPY/(2+NORDER),TOTEN-TOTENG
 
         IF ( WDES%NCDIJ>=2 ) THEN
-           WRITE(17,77281) RHOTOT(2:WDES%NCDIJ) 
+           WRITE(17,77281) RHOTOT(2:WDES%NCDIJ)
            IF (IO%IU0>=0) WRITE(TIU0,77281) RHOTOT(2:WDES%NCDIJ)
         ELSE
            WRITE(17,*)
@@ -3572,7 +3572,7 @@
 !-----------------------------------------------------------------------
         ! change of the energy between two ionic step used as stopping criterion
         INFO%LSTOP=(ABS(TOTEN-TOTENG)<DYN%EDIFFG)
-        
+
         CALLMPI_C ( and_chain( LSTOP2 ))
         CALLMPI_C ( and_chain( INFO%LSTOP ))
 
@@ -3748,7 +3748,7 @@
 
 !   if we need to pull the brake, then POSION is reset to POSIOC
 !   except for molecular dynamics, where the next electronic
-!   step should indeed correspond to POSIOC 
+!   step should indeed correspond to POSIOC
       IF ( INFO%LSTOP .AND. DYN%IBRION>0 ) THEN
          LATT_CUR%A=DYN%AC
          DYN%POSION=DYN%POSIOC
@@ -3774,22 +3774,22 @@
       IF (SMEAR_LOOP%ISMCNT/=0) THEN
          KPOINTS%ISMEAR=NINT(SMEAR_LOOP%SMEARS(2*SMEAR_LOOP%ISMCNT-1))
          KPOINTS%SIGMA=SMEAR_LOOP%SMEARS(2*SMEAR_LOOP%ISMCNT)
-         
+
          SMEAR_LOOP%ISMCNT=SMEAR_LOOP%ISMCNT-1
-         
+
          io_begin
          IF (IO%IU0>=0) &
               WRITE(TIU0,7283) KPOINTS%ISMEAR,KPOINTS%SIGMA
          WRITE(17,7283) KPOINTS%ISMEAR,KPOINTS%SIGMA
          io_end
-         
+
 7283     FORMAT('ISMEAR = ',I4,' SIGMA = ',F10.3)
-         
+
          KPOINTS%LTET=((KPOINTS%ISMEAR<=-4).OR.(KPOINTS%ISMEAR>=30))
          IF (KPOINTS%ISMEAR==-6) KPOINTS%ISMEAR=-1
          IF (KPOINTS%ISMEAR>=0)  KPOINTS%ISMEAR=MOD(KPOINTS%ISMEAR,30)
          SIGMA=ABS(KPOINTS%SIGMA)
-         
+
          CALL DENSTA( IO%IU0, IO%IU6, WDES, W, KPOINTS, INFO%NELECT, &
               INFO%NUP_DOWN, E%EENTROPY, EFERMI, SIGMA, .FALSE.,  &
               NEDOS, 0, 0, DOS, DOSI, PAR, DOSPAR)
@@ -3861,13 +3861,13 @@
 8022   FORMAT(/' mean value of Nose-termostat <S>:',F10.3, &
             &        ' mean value of <T> :',F10.3/ &
             &        ' mean temperature <T/S>/<1/S>  :',F10.3/)
-       
+
        DO  I=0,PACO%NPACO-1
           WRITE(60,'(F7.3)') &
                PCFAK*PACO%SIPACO(I)/ REAL( 3*I*(I+1)+1 ,KIND=q) /SMEANP
        ENDDO
        IF (IO%LOPEN) CALL WFORCE(60)
-       
+
     IF (.NOT. LJ_ONLY) THEN
        DELTAE=(KPOINTS%EMAX-KPOINTS%EMIN)/(NEDOS-1)
 
@@ -3975,8 +3975,8 @@
         DO ISP=2,WDES%NCDIJ
            CALL RC_ADD(CHTOT(1,ISP),0.0_q,CHTOT(1,ISP),0.0_q,CHTOT(1,ISP),GRIDC)
         ENDDO
-        ! add Gaussian "charge-transfer" charges, if required 
-        CALL RHOADD_GAUSSIANS(T_INFO,LATT_CUR,P,GRIDC,NCDIJ,CHTOT,CSTRF) 
+        ! add Gaussian "charge-transfer" charges, if required
+        CALL RHOADD_GAUSSIANS(T_INFO,LATT_CUR,P,GRIDC,NCDIJ,CHTOT,CSTRF)
         CALL RHOADD_GAUSSIANS_LIST(LATT_CUR,GRIDC,NCDIJ,CHTOT)
       ENDIF
 
@@ -4140,7 +4140,7 @@
            CHDEN, LMDIM, CRHODE, CHTOT, RHOLM, N_MIX_PAW, IRDMAX)
 
       CALL SET_KINEDEN(GRID,GRID_SOFT,GRIDC,SOFT_TO_C,LATT_CUR,SYMM, &
-           T_INFO%NIONS,W,WDES,KINEDEN)      
+           T_INFO%NIONS,W,WDES,KINEDEN)
 
       INFO%LPOTOK=.FALSE.
 
@@ -4231,7 +4231,7 @@
          CALL OUTPOS(18,.FALSE.,INFO%SZNAM1,T_INFO,LATT_CUR%SCALE,LATT_CUR%A,.FALSE.,DYN%POSION)
          io_end
 ! if you uncomment the following lines the pseudo core charge density
-! is added to the pseudo charge density         
+! is added to the pseudo charge density
 !         CALL FFT3D(CHTOT(1,1),GRIDC,1)
 !         CALL RL_ADD(CHTOT(1,1),1._q/GRIDC%NPLWV,DENCOR(1),1._q/GRIDC%NPLWV,CHTOT(1,1),GRIDC)
 !         CALL FFT3D(CHTOT(1,1),GRIDC,-1)
@@ -4345,7 +4345,7 @@
              GRIDC,GRIDUS,C_TO_US,SOFT_TO_C, &
              CHTOT,DENCOR,CVTOT,CSTRF, &
              CDIJ,CQIJ,CRHODE,N_MIX_PAW,RHOLM, &
-             CHDEN,SV,LMDIM,IRDMAX,EFERMI,NEDOS, & 
+             CHDEN,SV,LMDIM,IRDMAX,EFERMI,NEDOS, &
              LPOT= EXXOEP==0 .AND. INFO%INICHG/=4 .AND.  .NOT. USE_OEP_IN_GW() .AND. .NOT. LDO_METAGGA())
          ! potential must not be updated for OEP methods
          ! if potential was read from a file INFO%INICHG/=4
@@ -4410,14 +4410,14 @@
          IF (WDES%COMM_KINTER%NODE_ME.EQ.1) THEN
 #endif
          OPEN(UNIT=99,FILE=DIR_APP(1:DIR_LEN)//'AECCAR2',STATUS='UNKNOWN')
-         io_begin     
+         io_begin
          ! write header
          CALL OUTPOS(99,.FALSE.,INFO%SZNAM1,T_INFO,LATT_CUR%SCALE,LATT_CUR%A, &
         &             .FALSE., DYN%POSION)
          io_end
          ! write AE charge density
          CALL OUTCHG(GRIDC,99,.TRUE.,CHTOT)
-         CLOSE(99)     
+         CLOSE(99)
          ! write Fourier transform of AE charge density
          IF (LWRTSTRF()) THEN
             OPEN(UNIT=99,FILE=DIR_APP(1:DIR_LEN)//'STRFAC',STATUS='UNKNOWN')
@@ -4514,15 +4514,15 @@
 !     ELSE IF (JOBPAR/=0 .OR. IO%LORBIT>=10  ) THEN
       IF (JOBPAR/=0 .OR. IO%LORBIT>=10  ) THEN
          DEALLOCATE(PAR,DOSPAR)
-         
+
          IF (IO%LORBIT==1 .OR. IO%LORBIT==2 .OR. (IO%LORBIT>=11 .AND. IO%LORBIT<=14)) THEN
             LPAR=LMDIMP
          ELSE
             LPAR=LDIMP
          ENDIF
-         
+
          ALLOCATE(PAR(WDES%NB_TOT,WDES%NKPTS,LPAR,T_INFO%NIONP,WDES%NCDIJ))
-         
+
          IF (IO%LORBIT>=10) THEN
             CALL SPHPRO_FAST( &
                  GRID,LATT_CUR, P,T_INFO,W, WDES, 71,IO%IU6,&
@@ -4536,11 +4536,11 @@
                  GRID,LATT_CUR, P,T_INFO,W, WDES, 71,IO%IU6,&
                  INFO%LOVERL,LMDIM,CQIJ, LPAR, LDIMP, LMDIMP, LTRUNC, IO%LORBIT,PAR)
          ENDIF
-         
+
          CALL CHGLOC(WDES%NB_TOT,KPOINTS%NKPTS,LPAR,T_INFO%NIONS,WDES%ISPIN,PAR,W%FERWE)
-         
+
          !  get and write partial / projected DOS ...
-         
+
          !  some compilers require to remove this statment
          DEALLOCATE(W%CW)         ! make space free so that DOSPAR can take this space
          ALLOCATE (DOSPAR(NEDOS,LPAR,T_INFO%NIONP,WDES%NCDIJ))
@@ -4556,7 +4556,7 @@
             EN=KPOINTS%EMIN+DELTAE*(I-1)
             WRITE(16,7062) EN,(DOS(I,ISP)/DYN%KBLOCK,ISP=1,WDES%ISPIN),(DOSI(I,ISP)/DYN%KBLOCK,ISP=1,WDES%ISPIN)
          ENDDO
-         
+
          DO NI=1,T_INFO%NIONP
             WRITE(16,'(2F16.8,I5,2F16.8)') KPOINTS%EMAX,KPOINTS%EMIN,NEDOS,EFERMI,1.0
             DO I=1,NEDOS
@@ -4565,7 +4565,7 @@
                     &            EN,((DOSPAR(I,LPRO,NI,ISP),ISP=1,WDES%NCDIJ),LPRO=1,LPAR)
             ENDDO
          ENDDO
-         
+
          CALL XML_DOS(EFERMI, KPOINTS%EMIN, KPOINTS%EMAX, .TRUE., &
               DOS, DOSI, DOSPAR, NEDOS, LPAR, T_INFO%NIONP, WDES%NCDIJ)
          CALL XML_PROCAR(PAR, W%CELTOT, W%FERTOT, WDES%NB_TOT, WDES%NKPTS, LPAR ,T_INFO%NIONP,WDES%NCDIJ)
@@ -4574,7 +4574,7 @@
          CALL DENSTA( IO%IU0, IO%IU6, WDES, W, KPOINTS, INFO%NELECT, &
               INFO%NUP_DOWN, E%EENTROPY, EFERMI, KPOINTS%SIGMA, .FALSE.,  &
               NEDOS, 0, 0, DOS, DOSI, PAR, DOSPAR)
-         
+
          io_begin
          DELTAE=(KPOINTS%EMAX-KPOINTS%EMIN)/(NEDOS-1)
 
@@ -4773,7 +4773,7 @@
 
          ENDIF
       ENDIF
-      
+
       END SUBROUTINE ELECTRONIC_OPTIMIZATION
 
 !**********************************************************************
@@ -4814,7 +4814,7 @@
                  CHDEN,SV,DOS,DOSI,CHAM, &
                  8,LMDIM,IRDMAX,NEDOS, &
                  TOTEN,EFERMI, TIFOR)
-            
+
             CALL WRITE_RPA_FORCE( TIFOR, T_INFO, LATT_CUR, SYMM, DYN%POSIOC, DYN%IBRION, IO)
             CALL SEPERATOR_TIMING(IO%IU6)
             CALL STOP_TIMING("LOOPX",IO%IU6,'LINEAR')
